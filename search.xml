<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript使用技巧]]></title>
    <url>%2Farticles%2F3889315015.html</url>
    <content type="text"><![CDATA[本文抄录自https://juejin.im/post/5ecc87386fb9a047d245c7e1 引言整理了自己开发中常用的一些 js 技巧，灵活的运用，会增强你解决问题的能力，也会对你的代码简洁性有很大的改观。 数组去重1234567function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log("type error!"); return; &#125; return Array.from(new Set(arr));&#125; 数组转化为对象123456const arr = [1,2,3]const obj = &#123;...arr&#125;console.log(obj)Output:&#123;0: 1, 1: 2, 2: 3&#125; 转换为数字类型12345const age = "69";const ageConvert = +age;console.log(typeof ageConvert);Output: number; 转换为字符串类型123let a = 123;a + ""; // '123' 性能追踪12345678let start = performance.now();let sum = 0;for (let i = 0; i &lt; 100000; i++) &#123; sum += 1;&#125;let end = performance.now();console.log(start);console.log(end); 合并对象1234567const obj1 = &#123; a: 1 &#125;const obj2 = &#123; b: 2 &#125;const combinObj = &#123; ...obj1, ...obj2 &#125;console.log(combinObj)Output:&#123; a: 1, b: 2 &#125; 数组扁平化es6 提供了一个新方法 flat(depth)，参数 depth，代表展开嵌套数组的深度，默认是 1 12let arr = [1, [2, 3, [4, [5]]]];arr.flat(3); // [1,2,3,4,5] 获取数组中的最后一项12345let arr = [0, 1, 2, 3, 4, 5];const last = arr.slice(-1)[0];console.log(last);Output: 5; 美化你的JSON日常开发中，我们会经常用到JSON.stringify，但大家可能并不大清楚他具体有哪些参数。他有三个参数： json: 必须，可以是数组或 Objectreplacer: 可选值，可以是数组，也可以是方法space: 用什么来进行分隔而我们恰恰可以指定第三个参数 space 的值去美化我们的 JSON： 12let info = &#123; name: "森林", age: 1000 &#125;;console.log(JSON.stringify(info, null, 2)); Object.create(null)在 Vue 和 Vuex 的源码中，作者都使用了Object.create(null)来初始化一个新对象。为什么不用更简洁的{}呢？ 我们来看下Object.create()的定义： 1Object.create(proto, [propertiesObject]); proto:新创建对象的原型对象propertiesObject:可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。 Object.freeze()在 Vue 的文档中介绍数据绑定和响应时，特意标注了对于经过 Object.freeze() 方法的对象无法进行更新响应。 Object.freeze() 方法用于冻结对象，禁止对于该对象的属性进行修改。 像一些纯展示类的页面，可能存在巨大的数组或对象，如果这些数据不会发生更改，那么你就可以使用 Object.freeze()将他们冻结，这样 Vue 就不会对这些对象做 setter 或 getter 的转换，可以大大的提升性能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue内存泄漏优化]]></title>
    <url>%2Farticles%2F2666040323.html</url>
    <content type="text"><![CDATA[背景记一次项目内存泄漏优化。 通常我们在开发 Vue 的时候,大部分是在开发单页应用。但是，在单页应用的设计中，使用它是不需要刷新浏览器的，所以 JavaScript 应用需要自行清理组件来确保垃圾回收以预期的方式生效。通常我们在把其他库集成到应用时才会产生内存泄漏。 垃圾回收机制要想解决内存泄漏问题，必须先了解浏览器的垃圾回收机制。 下面是摘抄的《高级程序设计》3 的片段 总的来说垃圾收集机制的原理： 垃圾收集器会按照固定的时间间隔，周期性的找出不再继续使用的变量，然后释放其占用的内存。 什么叫不再继续使用的变量？ 不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。 全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。全局变量最好不要用 垃圾回收 通用的 两种方式：标记清除：当前采用的垃圾收集策略和引用计数 哪些情况会造成内存泄漏？意外的全局变量上面提到了全局变量不会被当成垃圾回收，但是我们在写代码时会出现下面这种情况： 12345function foo() &#123; this.bar2 = "默认绑定this指向全局"; // 全局变量=&gt; window.bar2 bar = "全局变量"; // 没有声明变量 实际上是全局变量=&gt;window.bar&#125;foo(); 解决方法： 1234567891011121314//方法1function foo() &#123; this.bar2 = "默认绑定this指向全局"; let bar = "全局变量"; //改为局部变量&#125;foo();//方法2function foo() &#123; this.bar2 = "默认绑定this指向全局"; bar = "全局变量";&#125;foo();window.bar = null; //手动释放delete window.bar2; 未被清楚的定时器和回调函数当不需要setInterval或者setTimeout时，定时器没有被 clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。 123456789let someResource = getData();setInterval(function() &#123; let node = document.getElementById('Node'); if(node) &#123; node.innerHTML = JSON.stringify(someResource)); // 定时器也没有清除 &#125; // node、someResource 存储了大量数据 无法回收&#125;, 1000); 解决方法： 12345678910let someResource = getData();let timer=setInterval(function() &#123; let node = document.getElementById('Node'); if(node) &#123; node.innerHTML = JSON.stringify(someResource)); // clearInterval(timer) &#125; // node、someResource 存储了大量数据 无法回收&#125;, 1000); 闭包闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏。 1234567function bindEvent() &#123; var obj = document.createElement("XXX"); var unused = function () &#123; console.log(obj, "闭包内引用obj obj不会被释放"); &#125;; // obj = null;&#125; 解决方法：手动解除引用，obj = null。 没有清理 DOM 元素引用123var refA = document.getElementById("refA");document.body.removeChild(refA); // dom删除了console.log(refA, "refA"); // 但是还存在引用 能console出整个div 没有被回收 console 保存大量数据在内存中过多的 console，比如定时器的 console 会导致浏览器卡死。 解决：合理利用 console，线上项目尽量少的使用 console，你也可以打包时全局关闭 console 如何避免内存泄漏记住一个原则：不用的东西，及时归还，毕竟你是’借的’嘛。 减少不必要的全局变量，使用严格模式避免意外创建全局变量。在你使用完数据后，及时解除引用(闭包中的变量，dom 引用，定时器清除)。组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。 关于内存泄漏即使是 1byte 的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。一般是堆区内存泄漏，栈区不会泄漏。基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以对象、数组之类的，才会发生内存泄漏。 Chrome 工具Chrome 提供了一套很棒的检测 JavaScript 内存占用的工具。与内存相关的两个重要的工具：memory 和 performance。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gzip性能优化方案]]></title>
    <url>%2Farticles%2F3844556024.html</url>
    <content type="text"><![CDATA[前言一个前端开发人员肯定知道线上环境要把 js、css、图片等压缩，提升页面加载速度，优化性能。 压缩方式前端自己打包压缩的有 grunt，gulp，webpack,fis 等等，此处只介绍 webpack Gzip 压缩 1npm i -D compression-webpack-plugin 12345678910111213141516//vue.config.jsconst CompressionPlugin = require("compression-webpack-plugin");module.exports = &#123; baseUrl: BASE_URL, chainWebpack: config =&gt; &#123; if (process.env.NODE_ENV === "production") &#123; config.plugin("compressionPlugin").use( new CompressionPlugin(&#123; test: /\.js$|\.html$|.\css/, // 匹配文件名 threshold: 10240, // 对超过10k的数据压缩 deleteOriginalAssets: false // 不删除源文件 &#125;) ); &#125; &#125;&#125;; 可见 Gzip 压缩可以节省很多时间 Nginx 配置1234567891011http &#123; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 9; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/javascript application/json; gzip_disable "MSIE [1-6]\."; gzip_vary on;&#125; 效果预览12//本地代码打包yarn build 配置本地的 Nginx 效果如下：]]></content>
      <tags>
        <tag>性能优化</tag>
        <tag>Gzip优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keep-alive 的实现原理和缓存策略]]></title>
    <url>%2Farticles%2F4126109409.html</url>
    <content type="text"><![CDATA[keep-alive的源码解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//src/core/components/keep-alive.jsimport &#123; isRegExp, remove &#125; from "shared/util";import &#123; getFirstComponentChild &#125; from "core/vdom/helpers/index";type VNodeCache = &#123; [key: string]: ?VNode &#125;;function getComponentName(opts: ?VNodeComponentOptions): ?string &#123; return opts &amp;&amp; (opts.Ctor.options.name || opts.tag);&#125;function matches( pattern: string | RegExp | Array&lt;string&gt;, name: string): boolean &#123; if (Array.isArray(pattern)) &#123; return pattern.indexOf(name) &gt; -1; &#125; else if (typeof pattern === "string") &#123; return pattern.split(",").indexOf(name) &gt; -1; &#125; else if (isRegExp(pattern)) &#123; return pattern.test(name); &#125; /* istanbul ignore next */ return false;&#125;function pruneCache(keepAliveInstance: any, filter: Function) &#123; const &#123; cache, keys, _vnode &#125; = keepAliveInstance; for (const key in cache) &#123; const cachedNode: ?VNode = cache[key]; if (cachedNode) &#123; const name: ?string = getComponentName(cachedNode.componentOptions); if (name &amp;&amp; !filter(name)) &#123; pruneCacheEntry(cache, key, keys, _vnode); &#125; &#125; &#125;&#125;function pruneCacheEntry( cache: VNodeCache, key: string, keys: Array&lt;string&gt;, current?: VNode) &#123; const cached = cache[key]; if (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123; cached.componentInstance.$destroy(); &#125; cache[key] = null; remove(keys, key);&#125;const patternTypes: Array&lt;Function&gt; = [String, RegExp, Array];export default &#123; name: "keep-alive", abstract: true, //抽象组件属性,参考此链接介绍 https://router.vuejs.org/zh/api/#routes props: &#123; include: patternTypes, // 被缓存组件 exclude: patternTypes, // 不被缓存组件 max: [String, Number] // 指定缓存大小 &#125;, created() &#123; this.cache = Object.create(null); //Object.create 创建一个对象，并继承传入对象的__proto__ //https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create this.keys = []; //缓存的key 列表 &#125;, destroyed() &#123; for (const key in this.cache) &#123; //清除缓存 pruneCacheEntry(this.cache, key, this.keys); &#125; &#125;, mounted() &#123; //监听缓存的变动 this.$watch("include", val =&gt; &#123; pruneCache(this, name =&gt; matches(val, name)); &#125;); //监听不缓存的变动 this.$watch("exclude", val =&gt; &#123; pruneCache(this, name =&gt; !matches(val, name)); &#125;); &#125;, render() &#123; const slot = this.$slots.default; const vnode: VNode = getFirstComponentChild(slot); // 获取第一个子元素的 vnode const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions; if (componentOptions) &#123; // check pattern const name: ?string = getComponentName(componentOptions); const &#123; include, exclude &#125; = this; //组件不在inlcude中或者在exlude中 直接返回vnode if ( // not included (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; return vnode; &#125; const &#123; cache, keys &#125; = this; const key: ?string = vnode.key == null ? // same constructor may get registered as different local components // so cid alone is not enough (#3269) componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : "") : vnode.key; if (cache[key]) &#123; //如果缓存存在，拿到缓存的组件，然后把它放在最后一位 vnode.componentInstance = cache[key].componentInstance; // make current key freshest remove(keys, key); keys.push(key); &#125; else &#123; //如果缓存不存在，把它放到缓存中 cache[key] = vnode; keys.push(key); // prune oldest entry if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; pruneCacheEntry(cache, keys[0], keys, this._vnode); &#125; &#125; vnode.data.keepAlive = true; &#125; return vnode || (slot &amp;&amp; slot[0]); &#125;&#125;;]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>keep-alive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端权限之动态路由树]]></title>
    <url>%2Farticles%2F1262276894.html</url>
    <content type="text"><![CDATA[前言在工作过程中，我们经常会遇到动态加载路由树的需求，本篇文章主要写动态加载路由树的实现方式。 路由定义项目中肯定有一些页面是每个用户都能访问的(如:登陆、注册)，这些路由我们可以直接做定义。 123456789101112131415161718192021222324252627282930313233343536//routers.jsexport default [ &#123; path: "/login", name: "login", meta: &#123; title: "登录", hideInMenu: true &#125;, component: () =&gt; import("@/view/login/login.vue") &#125;, &#123; path: "/401", name: "error_401", meta: &#123; hideInMenu: true &#125;, component: () =&gt; import("@/view/error-page/401.vue") &#125;, &#123; path: "/500", name: "error_500", meta: &#123; hideInMenu: true &#125;, component: () =&gt; import("@/view/error-page/500.vue") &#125; // &#123; // path: '*', // name: 'error_404', // meta: &#123; // hideInMenu: true // &#125;, // component: () =&gt; import('@/view/error-page/404.vue') // &#125;]; 1234567891011121314//router/index.jsimport Router from "vue-router";import routes from "./routers";// process.env.NODE_ENV 根据不同的环境 加载不同的路由模板处理文件const _import = require("./config/_import_" + process.env.NODE_ENV);Vue.use(Router);// console.log('process.env.WEBPACK_ENV', process.env.WEBPACK_ENV, process.env.BASE_URL);const router = new Router(&#123; base: process.env.BASE_URL, //此处是做项目基础路径的，可忽略 routes: routes, mode: "history"&#125;); 动态路由树1234567891011//login.vueimport &#123; mapActions &#125; from "vuex";export default &#123; methods: &#123; ...mapActions(["handleLogin", "initRoutes"]), handleSubmit(res) &#123; //后台返回路由树 this.initRoutes([this, res.resourceMenuDTO]); &#125; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536//store/app.jsimport &#123; addRoutes &#125; from "@/libs/util";export default &#123; state: &#123; local: localRead("local"), routers: GET_SESSION_STORAGE("_c_unparseRoutes") || [] &#125;, getters: &#123; routers: state =&gt; &#123; if (state.routers &amp;&amp; state.routers.length &gt; 0) &#123; return state.routers; &#125; else &#123; return JSON.parse(localStorage.getItem("_c_unparseRoutes")) || []; &#125; &#125;, homeRoute: (state, getters) =&gt; getHomeRoute(getters.routers, homeName) &#125;, mutations: &#123; setHomeRoute(state, routes) &#123; state.homeRoute = getHomeRoute(routes, homeName); &#125;, SET_ROUTER_CHANGE: (state, params) =&gt; &#123; SET_SESSION_STORAGE("router", params); state.router = params; &#125;, setRoutes(state, data) &#123; state.routers = data; &#125; &#125;, actions: &#123; initRoutes(&#123; commit, rootState &#125;, info) &#123; let router = addRoutes(info[0], info[1]); commit("setRoutes", router); &#125; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//libs/util.jsimport routes from "@/config/routes";/** * @description 根据后台数据返回动态生成路由树 * @param &#123;Object&#125; vm Vue实例 * @param &#123;Object&#125; routeItem 路由对象 */export const addRoutes = (vm, routeObj) =&gt; &#123; let routers = []; btnPre = []; Object.values(routeObj).forEach((elems, index) =&gt; &#123; if (elems.uri === "/") &#123; routes["home"].path = process.env.BASE_URL; routers.push(routes["home"]); &#125; let routeList = formatRouter(elems); routers = routers.concat(routeList); &#125;); routers.push(routes["404"]); // 坑：如不在此时添加404 刷新页面会自动跳转404 localStorage.setItem("_c_unparseRoutes", JSON.stringify(routers)); return routers;&#125;;export const formatRouter = (elems, name) =&gt; &#123; let routeList = []; elems.childList.forEach((elems2, index) =&gt; &#123; let route = getCurPage(elems2.uri); if (elems2.childList &amp;&amp; elems2.childList.length &gt; 0) &#123; let child = formatRouter(elems2, elems2.uri); route.children = child; &#125; if (route) &#123; routeList.push(route); &#125; &#125;); return routeList;&#125;; 1234567891011121314151617181920212223242526272829303132333435//config/routes.jsexport default &#123; home: &#123; path: "/", redirect: "/AuthManage/UserManage", component: "main", meta: &#123; hideInMenu: true, icon: "_quanxian", title: "权限管理", notCache: true &#125; &#125;, AuthManage: &#123; path: "/AuthManage", name: "AuthManage", redirect: "/AuthManage/UserManage", component: "main", meta: &#123; hideInMenu: false, icon: "_quanxian", title: "权限管理", notCache: true &#125; &#125;, 404: &#123; path: "*", name: "error_404", meta: &#123; hideInMenu: true &#125;, component: "view/error-page/404" &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//router/index.js//路由拦截var getRouter;function routerGo(to, next) &#123; // 过滤路由 调用filterAsyncRouter 数据模板处理方法 返回Vue-router可以识别数据 getRouter = filterAsyncRouter(getRouter); // 动态添加所有的的路由 router.addRoutes(getRouter); store.commit('SET_ROUTER_CHANGE', routes.concat(getRouter)); // 调用next()放行 next(&#123; ...to, replace: true &#125;);&#125;function filterAsyncRouter(asyncRouterMap) &#123; // 遍历后台传来的路由字符串，转换为组件对象 递归方法 const accessedRouters = asyncRouterMap.filter(route =&gt; &#123; if (route.component) &#123; // 路由有component if (route.component === 'main') &#123; // 判断路由是Layout 布局组件，将上方引用的Layout布局组件放进去 route.component = Main; &#125; else &#123; // 路由不是Layout组件 二级也main if (route.component === 'parentView') &#123; route.component = parentView; &#125; else &#123; route.component = _import(route.component); &#125; &#125; &#125; // 判断当前的路由对象中是否含有children 有再次调用本方法 递归调用 直到没有 if (route.children &amp;&amp; route.children.length) &#123; route.children = filterAsyncRouter(route.children); &#125; return true; &#125;); return accessedRouters;&#125;//注：此处为多加的beforeEach中间件，不要跟自己写的重合在一起。router.beforeEach((to, from, next) =&gt; &#123; iView.LoadingBar.start(); let routers = store.getters.routers; if (routers &amp;&amp; routers.length &gt; 0) &#123; if (!getRouter) &#123; // 判断有没有路由权限 没有 路由权限 重新请求|从Vuex中获取 getRouter = routers; // 拿到路由 routerGo(to, next); // 调用动态添加路由的方法 &#125; else &#123; // 判断有没有路由列表 有 允许进入下个这里是第二个beforeEach next(); &#125; &#125; else &#123; // 判断 数据仓库中有没有 用户登录返回的路由列表 没有 ===&gt;去登陆页 setCookie('oscsToken', ''); next(&#123; name: LOGIN_PAGE_NAME // 跳转到登录页 &#125;); &#125;)]]></content>
      <tags>
        <tag>权限管理</tag>
        <tag>VUE权限管理</tag>
        <tag>VUE动态路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端权限之按钮级别控制]]></title>
    <url>%2Farticles%2F1414629290.html</url>
    <content type="text"><![CDATA[前言由于公司新项目需要做全集团组织架构后台管理系统,所以需要做到动态路由树和按钮级别权限。什么?你说为啥这么麻烦？按角色权限不好吗？ 我一个小前端哪有什么话语权… T_T 。 配置篇1、首先要跟后台约定按钮权限树(用户进入页面 都有哪些按钮权限) 2、每个页面都有查看、编辑、添加、删除等权限(这些权限分类基本可以 cover 项目需求,不够再加…) 3、登录时获取该用户已有的权限 4、把得到的按钮权限生成数组,放到sessionstorage中保存 5、定义权限判断指令 123456789101112131415161718//directives.jsconst directives = &#123; has: &#123; inserted: function(el, binding, vnode) &#123; // 获取页面按钮权限 let _flag = false; if (binding.value) &#123; _flag = true; &#125; if (_flag &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el); &#125; &#125; &#125;&#125;;export default directives; 12//directive/index.jsVue.directive("has", directive.has); 123456789101112131415161718192021//libs/has.jsimport &#123; GET_SESSION_STORAGE &#125; from "@/libs/util";/** * @name 按钮权限管理 * * @param &#123;*&#125; Vue */const install = function(Vue) &#123; Vue.prototype.$_has = function(value) &#123; let _flag = false; let btnPermissions = GET_SESSION_STORAGE("btnPermissions"); if (btnPermissions &amp;&amp; btnPermissions.length &gt; 0) &#123; // 判断当前传值在权限树中是否存在 _flag = btnPermissions.indexOf(value) &gt; -1 ? true : false; &#125; return _flag; &#125;;&#125;;export default install; 123//main.jsimport has from "@/libs/has";Vue.use(has); 6、页面绑定自定义指令分为两种:一种页面上的按钮、一种组件中的按钮(这种不能使用自定义指令) 第一种、 123456789&lt;button type="primary" class="search-btn" :loading="loading" v-has="'Resource-readOnly'" @click="handleGetResourceTreeList"&gt; 查询&lt;/button&gt; 第二种、 12345//这种直接用我们在main.js中写的方法即可&lt;template v-if="$_has('ResourceManage-edit')"&gt; &lt;div class="operation-btn" @click="handleTableEdit(scope.row)"&gt;编辑&lt;/div&gt; &lt;div class="operation-btn" @click="handleTableRole(scope.row)"&gt;角色关联&lt;/div&gt;&lt;/template&gt; 效果预览首先该用户有页面权限 去掉删除按钮资源绑定的角色]]></content>
      <tags>
        <tag>权限控制</tag>
        <tag>VUE自定义指令</tag>
        <tag>VUE按钮权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[baidusitemap SEO优化]]></title>
    <url>%2Farticles%2F1899378046.html</url>
    <content type="text"><![CDATA[前言百度作为当前国内最大的搜索引擎，为了增加博客的访问量，所以我做了 SEO 优化。 效果图如下: python 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# coding:utf-8import requestsimport timefrom bs4 import BeautifulSoup as bpprint('自动推送开启....', 'utf-8')time.sleep(0.5)site_url = 'https://******.github.io/baidusitemap.xml'try: print('获取sitemap链接....', 'utf-8') # print requests.get(site_url).content data_ = bp(requests.get(site_url).content, "html.parser") print('成功', 'utf-8') print(data_.url)except ZeroDivisionError as err: print(data_.url) print(err)list_url = []def get_(data): headers = &#123;'User-Agent': 'curl/7.12.1 ', 'Content-Type': 'text/plain '&#125; try: r = requests.post( url='http://data.zz.baidu.com/urls?site=yuwangi.github.io&amp;token=***token***', data=data) print(r.status_code) print(r.content) except ZeroDivisionError as err: print(err)print(data_.find_all('loc'))print('---------------------------------')for x, y in enumerate(data_.find_all('loc')): print(x, y.string) list_url.append(y.string.replace('http://', 'http://www.'))print('---------------------------------')print('开始推送....', 'utf-8')for x in list_url: print('当前推送条目为:' + x, 'utf-8') time.sleep(2) get_(x) 运行:]]></content>
      <tags>
        <tag>SEO</tag>
        <tag>baidusitemap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发环境配置]]></title>
    <url>%2Farticles%2F1223383549.html</url>
    <content type="text"><![CDATA[背景开发过程中，我们经常遇到测试环境需要一种配置，线上环境另外一种配置，每次上线前都要修改一下配置，这样的管理会给我们的开发工作带来一些不必要的麻烦，所以就需要对前端开发环境进行一个配置。 那么如何才能做环境的配置呢？这里我们就用到Node环境变量。 配置Node环境变量我们开发过程中经常遇到，就是process.env,然后我就查了一下官方文档http://nodejs.cn/api/process.html#process_process_env,pricess.env属性返回包含用户环境的对象。 我们主要可以用它来做开启 sourceMap、后端域名的切换、webpack 相关环境配置等等。 Windows 配置 12345678#node中常用的到的环境变量是NODE_ENV，首先查看是否存在set NODE_ENV#如果不存在则添加环境变量set NODE_ENV=production#环境变量追加值 set 变量名=%变量名%;变量内容set path=%path%;C:\web;C:\Tools#某些时候需要删除环境变量set NODE_ENV= Linux 配置 12345678910#node中常用的到的环境变量是NODE_ENV，首先查看是否存在echo $NODE_ENV#如果不存在则添加环境变量export NODE_ENV=production#环境变量追加值export path=$path:/home/download:/usr/local/#某些时候需要删除环境变量unset NODE_ENV#某些时候需要显示所有的环境变量env 所有系统都支持的配置 123456#首先我们需要安装一个npm 包npm install --save-dev cross-env# 然后在webpack中cross-env WEBPACK_ENV=dev vue-cli-service serve --open 实践12345678910111213141516//webpack配置module.exports = &#123; // Project deployment base // By default we assume your app will be deployed at the root of a domain, // e.g. https://www.my-app.com/ // If your app is deployed at a sub-path, you will need to specify that // sub-path here. For example, if your app is deployed at // https://www.foobar.com/my-app/ // then change this to '/my-app/' baseUrl: BASE_URL, publicPath: process.env.WEBPACK_ENV == "test" || process.env.WEBPACK_ENV == "dev" ? "/scm/" : "/", lintOnSave: true&#125;; 123456789//routerconst router = new Router(&#123; base: process.env.WEBPACK_ENV == "test" || process.env.WEBPACK_ENV == "dev" ? "/scm/" : "/", routes, mode: "history"&#125;); 123456789#package.json"scripts": &#123; "dev": "cross-env WEBPACK_ENV=dev vue-cli-service serve --open", "build": "cross-env WEBPACK_ENV=test vue-cli-service build",//测试环境 "prod": "cross-env WEBPACK_ENV=prod vue-cli-service build",//线上环境 "lint": "vue-cli-service lint", "test:unit": "vue-cli-service test:unit", "test:e2e": "vue-cli-service test:e2e" &#125;, Tips:由于资源限制 所以做的测试环境分级 测试环境线上环境]]></content>
      <tags>
        <tag>node-env</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支权限管理及Merge Request]]></title>
    <url>%2Farticles%2F1972266884.html</url>
    <content type="text"><![CDATA[前言团队开发过程中合并分支随意,遇到冲突总是几人坐在一起解决冲突，但是这种方式做不到过程的留痕。后期出现 bug 又忘记之前代码如何编写的了,因此需要使用 Git 的 Merge Request 进行过程管理和 code review。 角色权限管理在 GitLab 中角色的权限一般有：Guest、Reporter、Developer、Maintainer、Owner。 下面就来设置权限 Merge Request开发过程中拥有 Developer 权限的用户提交被保护分支时,需要在分支管理页面提交 Merge Request，然后填写开发的需求信息。如下图： Tips:因为此时无资源，所以从网上找的图片。 然后拥有 Maintainer 权限的用户做 code review,选择是同意合并，还是拒绝合并。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端埋点之数据监控]]></title>
    <url>%2Farticles%2F2142221546.html</url>
    <content type="text"><![CDATA[前言前端埋点主要是为了服务运营人员采集用户行为数据，进行后续数据分析工作的工具。]]></content>
      <tags>
        <tag>前端埋点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sentry 前端异常监控]]></title>
    <url>%2Farticles%2F1179895217.html</url>
    <content type="text"><![CDATA[前言起初神创造天地，天地处于一片混沌状态，神说，要有光，于是便有了光。———《圣经》 概述Sentry是一款国外的异常监控开源服务，名字翻译过来就是“哨兵”。有没有感觉像《冰与火》里的守夜人，其实也差不多，把 bug 想成异鬼就行了。 对于任何一个项目而言，本地测试肯定做不到 100%覆盖，而且，我们也不能保证用户能按照我们的预期进行操作，其实对我而言，用户才是最好的测试者，但是我们不能奢求每个用户遇到问题时候都会主动向我们反馈。 故而，我们需要在项目出现异常时主动对其进行收集上报，分析原因和影响后制定下一步解决方案。 配置1、首先访问官网https://sentry.io注册账号2、创建项目 选择你用的前端框架 12345678//下面是vue的安装方式，其他框架安装指示做就可以了# Using yarnyarn add @sentry/browseryarn add @sentry/integrations# Using npmnpm install @sentry/browsernpm install @sentry/integrations 注意下面的配置最好在 production 环境配置，否则会影响 debug 123456789//main.js配置import Vue from "vue";import * as Sentry from "@sentry/browser";import * as Integrations from "@sentry/integrations";Sentry.init(&#123; dsn: "https://214bbc6a0a66455d********51357ef6@sentry.io/1827364", integrations: [new Integrations.Vue(&#123; Vue, attachProps: true &#125;)]&#125;); 结语最后奉上效果图 bug 复现步骤]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Sentry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3 资源CDN优化加载]]></title>
    <url>%2Farticles%2F2654233593.html</url>
    <content type="text"><![CDATA[背景背景就是项目打包chunk-vendors依赖文件太大，导致初次加载很慢… 所以就用到了 CDN 优化加载。 配置对于 vue，vuex，vue-router，axios，iview 等我们可以利用 webpack 的 externals 参数来配置，这里我们设定只需要在生产环境中才需要使用。 第一步：首先找 CDN 托管路径(公司有 oss 存储服务器的忽略) https://www.bootcdn.cn/ bootstrap 的 cdn 托管服务 https://unpkg.com/ 包管理工具的 cdn 资源 第二步 vue.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243//判断是否为生产环境const isProduction = process.env.NODE_ENV === "production";//定义 CDN 路径const cdn = &#123; css: [], js: [ "https://cdn.bootcss.com/vue/2.5.10/vue.min.js", "https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js", "https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js", "https://cdn.bootcss.com/axios/0.18.0/axios.min.js", "http://img-hub.opechk.com/invoice/87SP000000023/iview.min.js" //此处是公司提供的阿里云的cdn ]&#125;;module.exports = &#123; configureWebpack: smp.wrap(&#123; //生产环境注入 cdn externals: (isProduction &amp;&amp; &#123; vue: "Vue", vuex: "Vuex", "vue-router": "VueRouter", axios: "axios", "view-design": "iview" &#125;) || &#123;&#125; &#125;), chainWebpack: config =&gt; &#123; // 生产环境配置 if (isProduction) &#123; // 生产环境注入 cdn config.plugin("html").tap(args =&gt; &#123; args[0].cdn = cdn; return args; &#125;); &#125; config.resolve.alias .set("@", resolve("src")) // key,value自行定义，比如.set('@@', resolve('src/components')) .set("_c", resolve("src/components")); config.resolve.symlinks(true); &#125;&#125;; 第三步 index.html配置 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0" /&gt; &lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico" /&gt; &lt;!-- 使用 CDN 的 CSS 文件 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.css) &#123; %&gt; &lt;link href="&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;" rel="stylesheet" /&gt; &lt;% &#125; %&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong &gt;We're sorry but iview-admin doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong &gt; &lt;/noscript&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;!-- 使用 CDN 的 JS 文件 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.js) &#123; %&gt; &lt;script src="&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;"&gt;&lt;/script&gt; &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; nginx 配置 本地预览效果1234567891011121314151617181920212223server &#123; listen 9007;//端口 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location ^~ /store/ &#123; //如果资源为根目录的请用/ # autoindex off; try_files $uri $uri/ /store/; alias F:\\www\\hub-frontend\\dist\\;//打包资源本地路径 index index.html; &#125; location /opec-store-api/ &#123;//接口转发 rewrite ^/opec-store-api/(.*)$ /opec-store-api/$1 break; #所有对后端的请求加一个api前缀方便区分，真正访问的时候移除这个前缀 # API Server proxy_pass http://test.test.test.test/;//需要转发的地址 #将真正的请求代理到serverB,即真实的服务器地址，ajax的url为/api/user/1的请求将会访问http://www.serverB.com/user/1 &#125;&#125; Node.js 静态文件服务器https://github.com/zeit/serve 1234npm install -g serve# -s 参数的意思是将其架设在 Single-Page Application 模式下# 这个模式会处理即将提到的路由问题serve -s dist]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue频繁切换页面、标签页解决方案]]></title>
    <url>%2Farticles%2F2616055594.html</url>
    <content type="text"><![CDATA[背景在平常的开发过程中，我们经常会遇到频繁切换菜单或者切换 tabs,而每一次切换都会调取接口返回数据渲染（接口请求过快，大部分还在pending中），那么这些请求就会极大的影响页面的性能，因为即便切换了页面，那些请求依然会触发下去。为了节省这部分性能，所以做了下面这些处理。 配置 Tips:本文主要根据 axios 来做的处理 axios 文件配置123456789101112131415161718192021222324//axios文件window.canCancelAxios = []; //全局 所有拦截对象存储window.canAxios = &#123;&#125;; //拦截对象去重// http request 拦截器axios.interceptors.request.use( config =&gt; &#123; let whiteList = ["/order/login.htm"]; // 白名单接口 if (config.url &amp;&amp; whiteList.every(item =&gt; !config.url.includes(item))) &#123; if (canAxios[config.url]) &#123; //过滤 &#125; else &#123; config.cancelToken = new axios.CancelToken(function(c) &#123; window.canCancelAxios.push(&#123; key: config.url || "", cancel: c &#125;); &#125;); &#125; &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;); 定义取消方法1234567891011121314151617181920212223/** * 取消axios请求 * @param cellArr 要取消的接口；如果不传参，则取消canCancelAxios保存的所有接口 */export function cancelAxios(cellArr = []) &#123; if (cellArr.length &gt; 0) &#123; cellArr.forEach(val =&gt; &#123; for (let i = 0; i &lt; window.canCancelAxios.length; i++) &#123; if (window.canCancelAxios[i].key === val) &#123; window.canCancelAxios[i].cancel(); window.canCancelAxios.splice(i, 1); i--; &#125; &#125; &#125;); &#125; else &#123; for (let i = 0; i &lt; window.canCancelAxios.length; i++) &#123; window.canCancelAxios[i].cancel(); window.canCancelAxios.splice(i, 1); i--; &#125; &#125;&#125; 路由切换时，取消 axios 请求12345import cancelAxios from "***";router.beforeEach((to, from, next) =&gt; &#123; cancelAxios(); // 进行其他业务操作&#125;); 切换 tab 页时,取消部分请求12345678910111213141516171819202122232425262728//此处用的iview ui,由于业务逻辑修改 把keep-alive关闭了... 此处忽略&lt;Tabs type="card" class="Tabs" :animated="false" @on-click="changeTabs"&gt; &lt;TabPane :label="PENDING_Title"&gt; &lt;!-- &lt;keep-alive&gt; --&gt; &lt;pending v-if="tabIndex == 0" /&gt; &lt;!-- &lt;/keep-alive&gt; --&gt; &lt;/TabPane&gt; &lt;TabPane :label="CONFIRMER_Title"&gt; &lt;!-- &lt;keep-alive&gt; --&gt; &lt;confirmer v-if="tabIndex == 1" /&gt; &lt;!-- &lt;/keep-alive&gt; --&gt; &lt;/TabPane&gt; &lt;TabPane :label="READY_TO_SHIP_Title"&gt; &lt;!-- &lt;keep-alive&gt; --&gt; &lt;readyShip v-if="tabIndex == 2" /&gt; &lt;!-- &lt;/keep-alive&gt; --&gt; &lt;/TabPane&gt; &lt;TabPane :label="SHIPPED_Title"&gt; &lt;!-- &lt;keep-alive&gt; --&gt; &lt;shipped v-if="tabIndex == 3" /&gt; &lt;!-- &lt;/keep-alive&gt; --&gt; &lt;/TabPane&gt; &lt;TabPane :label="CANCELED_Title"&gt; &lt;!-- &lt;keep-alive&gt; --&gt; &lt;canceled v-if="tabIndex == 4" /&gt; &lt;!-- &lt;/keep-alive&gt; --&gt; &lt;/TabPane&gt; &lt;/Tabs&gt; 12345678//此处就是 切换tabs时 tabIndex会改变,当值变化时 取消一些正在请求的接口import &#123; cancelAxios &#125; from "@/libs/cancelAxios";watch: &#123; tabIndex() &#123; this.cancelAxios(["/order/listOrder.htm"]); &#125; &#125;, 结尾最后奉上效果图]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端面试总结]]></title>
    <url>%2Farticles%2F3335497093.html</url>
    <content type="text"><![CDATA[CSSflex 布局 上下左右居中 12345678910111213141516171819202122//csshtml,body &#123; eight: 100%&#125;.main &#123; display: flex; height: 100%; justify-content: center; align-items: center&#125;.box &#123; width: 300px; border: 1px solid red;&#125;//html&lt;div class="main"&gt; &lt;div class="box"&gt;上下左右居中&lt;/div&gt;&lt;/div&gt; 左右布局，一侧定宽，一侧自适应撑满 123456789101112131415161718192021222324252627282930//css html, body &#123; height: 100% &#125; .main &#123; display: flex; height: 100%; &#125; .left, .right &#123; height: 100%; border: 1px solid red; box-sizing: border-box; &#125; .left &#123; width: 300px; &#125; .right &#123; width: 100%; &#125; //html &lt;div class="main"&gt; &lt;div class="left"&gt;固定宽度300px&lt;/div&gt; &lt;div class="right"&gt;自适应宽度&lt;/div&gt; &lt;/div&gt; 内容宽度等分 123456789101112131415//css .box &#123; display: flex; &#125; .box div &#123; flex: 1; border: 1px solid red; &#125;//html &lt;div class="box"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;/div&gt; css3 的新特性 渐变线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 1background: linear-gradient(direction, color-stop1, color-stop2, ...); 径向渐变（Radial Gradients）- 由它们的中心定义 1background: radial-gradient(center, shape size, start-color, ..., last-color); 过渡 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 1234567891011div &#123; transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 2s; /* Safari */ -webkit-transition-property: width; -webkit-transition-duration: 1s; -webkit-transition-timing-function: linear; -webkit-transition-delay: 2s;&#125; 动画 属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 animation-play-state 属性 animation-name 规定 @keyframes 动画的名称 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 animation-delay 规定动画何时开始。默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 1234567891011121314151617div &#123; animation-name: myfirst; animation-duration: 5s; animation-timing-function: linear; animation-delay: 2s; animation-iteration-count: infinite; animation-direction: alternate; animation-play-state: running; /* Safari and Chrome: */ -webkit-animation-name: myfirst; -webkit-animation-duration: 5s; -webkit-animation-timing-function: linear; -webkit-animation-delay: 2s; -webkit-animation-iteration-count: infinite; -webkit-animation-direction: alternate; -webkit-animation-play-state: running;&#125; 用纯 CSS 创建一个三角形1234567891011121314 &lt;style&gt; div &#123; width: 0; height: 0; border-top: 40px solid transparent; border-left: 40px solid transparent; border-right: 40px solid transparent; border-bottom: 40px solid #ff0000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; CSS 的盒子模型标准盒子模型：宽度=内容的宽度（content）+ border + padding 低版本 IE 盒子模型：宽度=内容宽度（content+border+padding) 如何让一个 div 水平居中已知宽度，block 元素 ，添加添加 margin:0 auto 属性。未知宽度，绝对定位的居中 ，上下左右都为 0，margin:auto 让一个 div 水平垂直居中12345678910111213141516171819202122div &#123; position: relative; width: 500px; height: 300px; top: 50%; left: 50%; margin-top: -150px; margin-left: -250px; /*外边距为自身宽高的一半 */ background-color: red; /* 方便看效果 */&#125;.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;.container div &#123; width: 100px; /* 可省 */ height: 100px; /* 可省 */ background-color: red; /* 方便看效果 */&#125; 三栏布局，左右固定，中间自适应123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .middle, .left, .right &#123; position: relative; float: left; min-height: 130px; &#125; .container &#123; padding: 0 220px 0 200px; overflow: hidden; &#125; .left &#123; margin-left: -100%; left: -200px; width: 200px; background: red; &#125; .right &#123; margin-left: -220px; right: -220px; width: 220px; background: green; &#125; .middle &#123; width: 100%; background: blue; word-break: break-all; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='container'&gt; &lt;div class='middle'&gt;&lt;/div&gt; &lt;div class='left'&gt;&lt;/div&gt; &lt;div class='right'&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; CSS 优先级12345678910同级别：总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 1.属性后面加!import 会覆盖页面内任何位置定义的元素样式 2.作为style属性写在元素内的样式 3.id选择器 4.类选择器 5.标签选择器 6.通配符选择器（*） 7.浏览器自定义或继承**同一级别：后写的会覆盖先写的** JSES6 的新特性 此条必问~参考这篇文章 https://blog.csdn.net/zgrkaka/article/details/82863445 什么是闭包闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。 js 检测数据类型的方法 typeof 12345678console.log(typeof "");console.log(typeof 1);console.log(typeof true);console.log(typeof null);console.log(typeof undefined);console.log(typeof []);console.log(typeof function() &#123;&#125;);console.log(typeof &#123;&#125;); typeof 对于基本数据类型判断是没有问题的，但是遇到引用数据类型是不起作用的。 instanceof 12345678console.log("1" instanceof String);console.log(1 instanceof Number);console.log(true instanceof Boolean);// console.log(null instanceof Null);// console.log(undefined instanceof Undefined);console.log([] instanceof Array);console.log(function() &#123;&#125; instanceof Function);console.log(&#123;&#125; instanceof Object); 可以看到前三个都是以对象字面量创建的基本数据类型，但是却不是所属类的实例，这个就有点怪了。后面三个是引用数据类型，可以得到正确的结果。如果我们通过 new 关键字去创建基本数据类型，你会发现，这时就会输出 true,如下: 接下再来说说为什么 null 和 undefined 为什么比较特殊，实际上按理来说，null 的所属类就是 Null，undefined 就是 Undefined，但事实并非如此：控制台输出如下结果： 浏览器压根不认识这两货，直接报错。在第一个例子你可能已经发现了，typeof null 的结果是 object，typeof undefined 的结果是 undefined Object.prototype.toString.call() 12345678910let a = Object.prototype.toString;console.log(a.call("aaa"));console.log(a.call(1));console.log(a.call(true));console.log(a.call(null));console.log(a.call(undefined));console.log(a.call([]));console.log(a.call(function() &#123;&#125;));console.log(a.call(&#123;&#125;)); 完美的检测了所有的数据类型 谈一谈深拷贝和浅拷贝123//浅拷贝方法// Object.assign()// ... 12345678910111213141516171819202122//深拷贝 递归function deepClone(obj) &#123; let objClone = Array.isArray(obj) ? [] : &#123;&#125;; if (obj &amp;&amp; typeof obj === "object") &#123; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //判断ojb子元素是否为对象，如果是，递归复制 if (obj[key] &amp;&amp; typeof obj[key] === "object") &#123; objClone[key] = deepClone(obj[key]); &#125; else &#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125;let a = [1, 2, 3, 4], b = deepClone(a);a[0] = 2;console.log(a, b); 123456789101112//深拷贝//JSON对象的parse和stringifyfunction deepClone(obj) &#123; let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone;&#125;let a = [0, 1, [2, 3], 4], b = deepClone(a);a[0] = 1;a[2][0] = 1;console.log(a, b); call apply bind 的区别和实现方式123456789101112131415// call, apply, bind的区别var a = &#123; value: 1 &#125;;function getValue(name, age) &#123; console.log("arguments in fn = ", arguments); console.log(name, age); console.log(this.value);&#125;getValue.call(a, "yuwangi1", 17);let bindFoo = getValue.bind(a, "testBind", 45);console.log("bindFoo = ", bindFoo);bindFoo();getValue.apply(a, ["yuwangi2", 18]);var returnedFunc = getValue.bind(a, "yuwangi3", 19);console.log(returnedFunc);returnedFunc(); 执行结果： 可以看到，call, apply 都是直接返回函数执行后的结果，而 bind 是返回一个函数，之后手动执行之后才会将结果返回。 手写 call 方法 12345678910111213141516171819202122232425262728293031// 手写模拟call方法的思想/** * call方法思想：改变this指向，让新的对象可以执行这个方法 * 实现思路： * 1、给新的对象添加一个函数（方法），并让this（也就是当前绑定的函数）指向这个函数 * 2、执行这个函数 * 3、执行完以后删除这个方法 * 4、可以将执行结果返回 */Function.prototype.myCall = function(funcCtx) &#123; // funcCtx是当前要调用函数的对象 console.log("funcCtx = ", funcCtx); // this指被调用的函数 console.log("this = ", this); if (typeof this != "function") &#123; throw new TypeError("Erorr"); &#125; let ctx = funcCtx || global; console.log("arguemnets = ", arguments); let args = [...arguments].slice(1); console.log(`args = $&#123;args&#125;`); ctx.fn = this; // 为当前对象添加一个函数fn, 值为要已经定义的要调用的函数 console.log("ctx.fn = ", ctx.fn); // 执行添加的函数fn var result = ctx.fn(...args); // 执行完以后删除 delete ctx.fn; return result;&#125;;getValue.myCall(a, "test", 20); 手写 apply 方法 1234567891011121314151617181920// applyFunction.prototype.myApply = function(funcCtx) &#123; console.log(this); if (typeof this != "function") &#123; throw new TypeError("Erorr"); &#125; let ctx = funcCtx || global; ctx.fn = this; console.log("arguemnets = ", arguments); let result; if (arguments[1]) &#123; result = ctx.fn(...arguments[1]); &#125; else &#123; result = ctx.fn(); &#125; delete ctx.fn; return result;&#125;;getValue.myApply(a, ["eo", 50]); 手写 bind 方法 123456789101112131415161718192021//bind实现/** * 实现思想： * 1、返回一个函数，其他与call, apply类似 * 2、如果返回的函数作为构造函数，bind时指定的 this 值会失效，但传入的参数依然生效。 */Function.prototype.myBind = function(funcCtx) &#123; let ctx = funcCtx || global; console.log(this); let _this = this; let args = [...arguments].slice(1); // 作为构造函数使用 let Fbind = function() &#123; let self = this instanceof Fbind ? this : ctx; return _this.apply(self, args.concat(...arguments)); &#125;; let f = function() &#123;&#125;; f.prototype = this.prototype; Fbind.prototype = new f(); return Fbind;&#125;; 执行结果： 谈谈原型链javascript中万物皆对象。每个对象都有属于它的类，比如自然界中大象属于动物，火腿属于食物…,在 js 中每个实例也有它的类。 比方说现在我创建一个Person类。 123456789101112131415class Person &#123; //定义了一个名字为Person的类 constructor(name, age) &#123; //constructor是一个构造方法，用来接收参数 this.name = name; //this代表的是实例对象 this.age = age; &#125; say() &#123; //这是一个类的方法 return "我的名字叫" + this.name + "今年" + this.age + "岁了"; &#125;&#125;var obj = new Person("yuwangi", 18);console.log(obj.say()); //我的名字叫yuwangi今年18岁了console.log(obj.prototype); 这里每一个实例都拥有Person的 say 方法,实例的__proto__指向Person,Person的constructor.prototype还是Person。 网上找了个 关系图： 从输入 url 地址到页面相应都发生了什么12345671、浏览器的地址栏输入URL并按下回车。2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。4、根据IP建立TCP连接（三次握手）。5、HTTP发起请求。6、服务器处理请求，浏览器接收HTTP响应。7、渲染页面，构建DOM树。8、关闭TCP连接（四次挥手） session,cookie,sessionStorage,localStorage 的区别及应用场景保存位置cookie,sessionStorage,localStorage 都是保存在浏览器端的,session是保存在服务器端的 使用方式（1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。 Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它 （2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。 存储内容cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象) 存储的大小cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。 安全性cookie：针对cookie所存在的攻击：Cookie 欺骗，Cookie 截获；session的安全性大于cookie。 原因如下：（1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；（2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；（3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。（4）sessionID是加密的（5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。 应用场景 cookie：（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。（2）保存上次登录的时间等信息。（3）保存上次查看的页面（4）浏览计数 session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。（1）网上商城中的购物车（2）保存用户登录信息（3）将某些数据放入session中，供同一用户的不同页面使用（4）防止用户非法登录 缺点 cookie：（1）大小受限（2）用户可以操作（禁用）cookie，使功能受限（3）安全性较低（4）有些状态不可能保存在客户端。（5）每次访问都要传送 cookie 给服务器，浪费带宽。（6）cookie 数据有路径（path）的概念，可以限制 cookie 只属于某个路径下。 session：（1）Session 保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。（2）依赖于 cookie（sessionID 保存在 cookie），如果禁用 cookie，则要使用 URL 重写，不安全（3）创建 Session 变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用 session 变量将会导致代码不可读而且不好维护。 好了，下面再说说localStorage（本地存储）和sessionStorage（会话存储）。 生命周期 localStorage:localStorage 的生命周期是永久的，关闭页面或浏览器之后 localStorage 中的数据也不会消失 localStorage 除非主动删除数据，否则数据永远不会消失。 sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。 存储大小：localStorage 和 sessionStorage 的存储数据大小一般都是：5MB 存储位置：localStorage 和 sessionStorage 都保存在客户端，不与服务器进行交互通信。 存储内容类型：localStorage 和 sessionStorage 只能存储字符串类型，对于复杂的对象可以使用 ECMAScript 提供的 JSON 对象的 stringify 和 parse 来处理 获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。 应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录； WebStorage 的优点（1）存储空间更大：cookie 为 4KB，而 WebStorage 是 5MB； （2）节省网络流量：WebStorage 不会传送到服务器，存储在本地的数据可以直接获取，也不会像 cookie 一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量； （3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage 会非常方便； （4）快速显示：有的数据存储在 WebStorage 上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快； （5）安全性：WebStorage 不会随着 HTTP header 发送到服务器端，所以安全性相对于 cookie 来说比较高一些，不会担心截获，但是仍然存在伪造问题； （6）WebStorage 提供了一些方法，数据操作比 cookie 方便； setItem (key, value) —— 保存数据，以键值对的方式储存信息。 getItem (key) —— 获取数据，将键值传入，即可获取到对应的 value 值。 removeItem (key) —— 删除单个数据，根据键值移除对应的信息。 clear () —— 删除所有的数据 key (index) —— 获取某个索引的 key js 中跨域方法详情请看 多种跨域方案详解 https://yuwangi.github.io/articles/3222442466.html 数组去重的方法 一维数组排序 123456789//利用ES6中的 Set 方法去重let arr = [1, 0, 0, 2, 9, 8, 3, 1];function unique(arr) &#123; console.log(new Set(arr)); return Array.from(new Set(arr));&#125;console.log(unique(arr)); // [1,0,2,9,8,3]console.log(...new Set(arr)); // [1,0,2,9,8,3] 1234567891011121314151617var arr = [1, 2, 8, 9, 5, 8, 4, 0, 4];/* 模拟: 原始数组：[1,2,8,9,5,8,4,0,4] 索引值：0,1,2,3,4,5,6,7,8 伪新数组：[1,2,8,9,5,8,4,0,4] 使用indexOf方法找到数组中的元素在元素在中第一次出现的索引值 索引值：0,1,2,3,4,2,6,7,6 返回前后索引值相同的元素： 新数组：[1,2,8,9,5,4,0]*/function unique(arr) &#123; // 如果新数组的当前元素的索引值 == 该元素在原始数组中的第一个索引，则返回当前元素 return arr.filter(function(item, index) &#123; return arr.indexOf(item, 0) === index; &#125;);&#125;console.log(unique(arr)); // 1, 2, 8, 9, 5, 4, 0 多维数组排序 1234567891011121314151617181920var temp = [];function uniq(array) &#123; var result = []; recursion(array); // 调用递归将多维数组变为一维数组再去重 return Array.from(new Set(temp));&#125;// 新增递归函数function recursion(array) &#123; var len = array.length; for (var i = 0; i &lt; len; i++) &#123; if (typeof array[i] == "object") &#123; // 如若数组元素类型是object，则递归 recursion(array[i]); &#125; else &#123; temp.push(array[i]); // 否则添加到temp数组中 &#125; &#125;&#125;var arr = [1, [2, 3], [3, 2, [1, 6, [3, 5, "3"]]]];console.log(uniq(arr)); ajax 的状态码 200: 代表请求成功； 301: 永久重定向； 302: 临时转移 304: 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源] 307: 临时重定向 400: 数据/格式错误 401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的） 404: 路径错误，找不到文件 500: 服务器的问题 503: 超负荷； 异步解决方案 Promise await promise定时器、ajax、事件绑定、回调函数、async await、promise promise：1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败promise.all() 里面状态都改变，那就会输出，得到一个数组promise.race() 里面只有一个状态变为rejected或者fulfilled即输出promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//手写promiseclass CutePromise &#123; constructor(executor) &#123; // executor是我们实例化CutePromise时传入的参数函数，它接受两个参数，分别是resolve和reject。 // resolve和reject我们将会定义在constructor当中，供executor在执行的时候调用 if (typeof executor !== "function") &#123; throw new Error("Executor must be a function"); &#125; this.state = "PENDING"; this.chained = []; const resolve = res =&gt; &#123; if (this.state !== "PENDING") &#123; return; &#125; this.state = "FULFILLED"; this.internalValue = res; for (const &#123; onFulfilled &#125; of this.chained) &#123; onFulfilled(res); &#125; &#125;; const reject = err =&gt; &#123; if (this.state !== "PENDING") &#123; return; &#125; this.state = "REJECTED"; this.internalValue = err; for (const &#123; onRejected &#125; of this.chained) &#123; onRejected(err); &#125; &#125;; try &#123; executor(resolve, reject); &#125; catch (err) &#123; reject(err); &#125; &#125; // 为实例提供一个then的方法，接收两个参数函数， // 第一个参数函数必传，它会在promise已成功(fulfilled)以后被调用 // 第二个参数非必传，它会在promise已失败(rejected)以后被调用 then(onFulfilled, onRejected) &#123; if (this.state === "FULFILLED") &#123; onFulfilled(this.internalValue); &#125; else if (this.$state === "REJECTED") &#123; onRejected(this.internalValue); &#125; else &#123; this.chained.push(&#123; onFulfilled, onRejected &#125;); &#125; &#125;&#125; 测试代码： 12345678let p = new CutePromise(resolve =&gt; &#123; setTimeout(() =&gt; resolve("Hello"), 100);&#125;);p.then(res =&gt; console.log(res));p = new CutePromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject("err"), 100);&#125;);p.then(() =&gt; &#123;&#125;, err =&gt; console.log("Async error:", err)); 事件委托12345678910111213141516171819202122232425262728293031//html&lt;div id="box"&gt; &lt;input type="button" id="add" value="添加" /&gt; &lt;input type="button" id="remove" value="删除" /&gt; &lt;input type="button" id="move" value="移动" /&gt; &lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt;//jswindow.onload = function()&#123; var oBox = document.getElementById("box"); oBox.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input')&#123; switch(target.id)&#123; case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; &#125; &#125; &#125;&#125; 垃圾回收机制垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。 垃圾回收方式 标记清除（mark and sweep） 当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。 引用计数(reference counting) 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。 数组循环方法和效率详情请看这篇文章 https://yuwangi.github.io/articles/341754589.html setTimeout和Promise区别（宏任务和微任务）12345678910111213setTimeout(function() &#123; console.log('宏任务setTimeout'); //先遇到setTimeout，将其回调函数注册后分发到宏任务Event Queue //如果setTimeout设置时间，那它会先把函数放到宏任务Event Table,等时间到了再放入宏任务Event Queue里面&#125;)new Promise(function(resolve) &#123; console.log('微任务promise'); //new Promise函数立即执行 resolve();//必须resolve执行才能执行then&#125;).then(function() &#123; console.log('微任务then'); //then函数分发到微任务Event Queue&#125;)console.log('主线程console');//执行顺序结果： 微任务promise、主线程console、微任务then、宏任务setTimeout let、const面试题1234567//varfor(var i=0;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000)&#125;console.log(i)// 6 6 6 6 6 12345678//varfor(var i=0;i&lt;=5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;,j*1000) &#125;)()// 6 6 6 6 6&#125; 12345678//varfor(var i=0;i&lt;=5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;,j*1000) &#125;)(i)// 0 1 2 3 4&#125; 1234567//letlet i;for(i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); // 5 5 5 5 5 &#125;,1000)&#125; 123456//letfor(let i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); // 0 1 2 3 4 &#125;,1000)&#125; this作用域试题这些题请抹去答案后 自己想一下 1234if (true) &#123; var name = 'zhangsan'&#125;console.log(name) 1234if (true) &#123; let name1 = 'zhangsan'&#125;console.log(name1) // 报错，因为let定义的name是在if这个块级作⽤域 12345678910function aaa()&#123; a=10;&#125;aaa();function aaa()&#123; var a=b=10;&#125;aaa();console.log(b)//10console.log(a)//Uncaught ReferenceError: a is not defined 123456789101112131415161718192021var name = '222';var a = &#123; name : '111', say : function () &#123; console.log(this.name) &#125;&#125;var fun = a.say;fun() //222a.say() //111var b = &#123; name : '333', say : function (fun) &#123; fun(); &#125;&#125;b.say(a.say); //222b.say = a.say;b.say() //333 12345678910111213var val = 1var obj = &#123;val : 2,dbl : function() &#123; var val = 45; console.log(this); //window this.val *= 2; console.log(this.val); //2 console.log(val); //45 &#125;&#125;var fn = obj.dblfn() 12345var x = 12;function test() &#123; console.log(this.x)&#125;test() //12 123456789var x = 12;function test() &#123; console.log(this.x)&#125;var obj=&#123; x:45, ss:test&#125;obj.ss() //45 123456789101112var x = 12;function test() &#123; console.log(this.x)//12&#125;var obj = &#123; x:45, ss:function()&#123; console.log(this) test() &#125;&#125;obj.ss() //&#123;x: 45, ss: ƒ&#125; 123456789101112var val = 1var obj = &#123;val : 2,dbl : function() &#123; // var val = 45; console.log(this); // &#123;val: 2, dbl: ƒ&#125; this.val *= 2; console.log(this.val); // 4 console.log(val); // 1 &#125;&#125;var ff = obj.dbl() 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js 123``````js]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mocker-api-json]]></title>
    <url>%2Farticles%2F1427260442.html</url>
    <content type="text"><![CDATA[喜大普奔,我的npm包上线啦~！！！ 攻略1npm install mocker-api-json mocker-api --save-dev webpack dev文件 123456789101112131415161718192021222324252627282930313233const path = require('path');const webpack = require('webpack');const merge = require('webpack-merge');const BaseConfig = require('./webpack.base.js');const apiMocker = require('mocker-api');//webpack配置mode: 'development', devServer: &#123; host: '0.0.0.0', port: 9001, headers: &#123; 'Access-Control-Allow-Origin': '*' &#125;, historyApiFallback: &#123; rewrites: [&#123; from: /.*/g, to: '/www/view/index.html' &#125;] &#125;, proxy: &#123; '/api': &#123; target: 'http://test01.test.com:8091/' &#125; &#125;, before(app) &#123;//此处是重点`!!!!!!!!!!!!!!! //https://www.webpackjs.com/configuration/dev-server/#devserver-before apiMocker(app, path.resolve(__dirname, '../mock/index.js')); &#125; &#125;, mock/index.js文件 1234567const json = require("mocker-api-json");module.exports = json(&#123; mock: true, //全局打开mock dirname: __dirname, //当前文件路径 baseUrl: "api/", //公共请求链接 delay: 10 //延迟时间&#125;); 额… 目前只加了这几个配置，后续提 issues 再加吧 Mock 资源文件配置 json文件就这样 123456789101112131415161718192021&#123; "err_code": 0, "err_msg": "ok", "mock": true, //控制单个文件mock开关 "data": &#123; "poi": &#123; "z_id": "111111111111", "name": "中国技术交易大厦大厦大厦", "province": "", "city": "北京市", "district": "海淀区", "longitude": 116.307499005, "latitude": 39.111, "addr": "", "category": "房产小区:商务楼宇", "category_code": 281200, "expiration_label": 0, "phone": "" &#125; &#125;&#125; 后记大概就这些啦，如有问题yuwangi.github.io 联系我]]></content>
      <tags>
        <tag>Mock</tag>
        <tag>mocker-api-json</tag>
        <tag>Mock本地化配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 Map、WeakMap详解]]></title>
    <url>%2Farticles%2F1178710130.html</url>
    <content type="text"><![CDATA[概述如果你的 JavaScript 经验丰富的话，应该会了解对象是创建无序键/值对数据结构 [也称为 映射（map）] 的主要机制。但是，对象作为映射的主要缺点是不能使用非字符串值作为键。 举例来说，考虑： 123456789var m = &#123;&#125;;var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;m[x] = "foo";m[y] = "bar";m[x]; // "bar"m[y]; // "bar" 这里发生了什么？ x 和 y 两个对象字符串化都是 &quot;[object Object]&quot;，所以 m 中只设置了一个键。 Map在ES6中引入了 Map(..): 12345678910var m = new Map():var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;m.set( x, "foo" );m.set( y, "bar" );m.get( x ); // "foo"m.get( y ); // "bar" 这里唯一的缺点就是不能使用方括号 [ ] 语法设置和获取值，但完全可以使用 get(..) 和 set(..) 方法完美代替。 要从 map 中删除一个元素，不要使用 delete 运算符，而是要使用 delete() 方法： 1234m.set( x, "foo" );m.set( y, "bar" );m.delete( y ); 你可以通过 clear() 清除整个 map 的内容。要得到 map 的长度（也就是键的个数），可以 使用 size 属性（而不是 length）： 123456m.set( x, "foo" );m.set( y, "bar" );m.size; // 2m.clear();m.size; // 0 Map(..) 构造器也可以接受一个 iterable，这个迭代器必须产生一列数组，每个数组的第一个元素是键，第二个元素是值。这种迭代的形式和 entries() 方法产生的形式是完全一样的，这使得创建一个 map 的副本很容易： 1234var m2 = new Map( m.entries() );// 等价于：var m2 = new Map( m ); 因为 map 的实例是一个 iterable，它的默认迭代器与 entries() 相同，所以我们更推荐使用 后面这个简短的形式。当然，也可以在 Map(..) 构造器中手动指定一个项目（entry）列表（键 / 值数组的数组）： 12345678910var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;var m = new Map([ [ x, "foo" ], [ y, "bar"]]);m.get( x ); // "foo"m.get( y ); // "bar" Map取值要从map 中得到一列值，可以使用 values(..)，它会返回一个迭代器。比如spread 运算符 … 和 for..of 循环。另外， Array.from(..) 方法。考虑： 123456789101112var m = new Map();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;m.set( x, "foo" );m.set( y, "bar" );var vals = [ ...m.values() ];vals; // ["foo","bar"]Array.from( m.values() ); // ["foo","bar"] 可以在一个 map 的项目上使用 entries() 迭代（或者默认 map 迭代器）: 123456789101112131415var m = new Map();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;m.set( x, "foo" );m.set( y, "bar" );var vals = [ ...m.entries()];vals[0][0] === x; // truevals[0][1]; // "foo"vals[1][0] === y; // truevals[1][1]; // "bar" Map键值要得到一列键，可以使用 keys()，它会返回 map 中键上的迭代器： 123456789101112var m = new Map();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;m.set( x, "foo" );m.set( y, "bar" );var keys = [ ...m.keys()];keys[0] === x; // truekeys[1] === y; // true 要确定一个 map 中是否有给定的键，可以使用 has(..)方法: 123456789var m = new Map();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;m.set( x, "foo" );m.has( x ); // truem.has( y ); // false map 的本质是允许你把某些额外的信息（值）关联到一个对象（键）上，而无需把这个信 息放入对象本身。对于 map 来说，尽管可以使用任意类型的值作为键，但通常我们会使用对象，因为字符串 或者其他基本类型已经可以作为普通对象的键使用。换句话说，除非某些或者全部键需要是对象，否则可以继续使用普通对象作为影射，这种情况下 map 才更加合适。 Tips:如果使用对象作为映射的键，这个对象后来被丢弃（所有的引用解除），试图让垃圾回收（GC）回收其内存，那么 map 本身仍会保持其项目。你需要 从 map 中移除这个项目来支持 GC,这时候就需要 WeakMap。 WeakMapWeakMap 是 map 的变体，二者的多数外部行为特性都是一样的，区别在于内部内存分配 （特别是其 GC）的工作方式。WeakMap（只）接受对象作为键。这些对象是被弱持有的，也就是说如果对象本身被垃圾回收的话，在 WeakMap 中的这个项目也会被移除。然而我们无法观测到这一点，因为对象被垃圾回收的唯一方式是没有对它的引用了。但是一旦不再有引用，你也就没有对象引 用来查看它是否还存在于这个 WeakMap 中了。 除此之外，WeakMap 的 API 是类似的，尽管要更少一些: 123456789var m = new WeakMap();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;m.set( x, "foo" );m.has( x ); // truem.has( y ); // false WeakMap 没有 size 属性或 clear() 方法，也不会暴露任何键、值或项目上的迭代器。所以即使你解除了对 x 的引用，它将会因 GC 时这个条目被从 m 中移除，也没有办法确定这一事实。所以你就相信 JavaScript 所声明的吧 和 Map 一样，通过 WeakMap 可以把信息与一个对象软关联起来。而在对这个对象没有完 全控制权的时候，这个功能特别有用，比如 DOM 元素。如果作为映射键的对象可以被删除，并支持垃圾回收，那么 WeakMap 就更是合适的选择了。需要注意的是，WeakMap 只是弱持有它的键，而不是值。考虑： 12345678910111213141516var m = new WeakMap();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;, z = &#123; id: 3 &#125;, w = &#123; id: 4 &#125;;m.set( x, y );x = null; // &#123; id: 1 &#125; 可GCy = null; // &#123; id: 2 &#125; 可GC // 只因 &#123; id: 1 &#125; 可GCm.set( z, w );w = null; // &#123; id: 4 &#125; 不可GC]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>Map</tag>
        <tag>js</tag>
        <tag>WeakMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制：强缓存、协商缓存]]></title>
    <url>%2Farticles%2F2460136963.html</url>
    <content type="text"><![CDATA[概述良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度通常浏览器缓存策略分为两种：强缓存和协商缓存 基本原理 浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源 如果前面两者都没有命中，直接从服务器加载资源 相同点 如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据； 不同点强缓存不发请求到服务器，协商缓存会发请求到服务器。 强缓存强缓存通过Expires和Cache-Control两种响应头实现 ExpiresExpires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效 1Expires: Wed, 11 May 2018 07:20:00 GMT Cache-ControlCache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间 1Cache-Control: max-age=315360000 tips: Cache-Control: no-cache不会缓存数据到本地的说法是错误的，详情《HTTP权威指南》P182Cache-Control: no-store才是真正的不缓存数据到本地Cache-Control: public可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器Cache-Control: private只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存 协商缓存当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的 Last-Modified，If-Modified-SinceLast-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag ETag、If-None-MatchEtag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的 If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来 ETag的优先级比Last-Modified更高 具体为什么要用ETag，主要出于下面几种情况考虑： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。 整体流程图 几种状态码的区别 200：强缓Expires/Cache-Control存失效时，返回新的资源文件 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功 304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304 但是！但是！现在的200(from cache)已经变成了from disk cache(磁盘缓存)和from memory cache(内存缓存)两种打开chrome控制台看一下网络请求就知道了 如何选择合适的缓存大致的顺序 Cache-Control —— 请求服务器之前 Expires —— 请求服务器之前 If-None-Match (Etag) —— 请求服务器 If-Modified-Since (Last-Modified) —— 请求服务器 协商缓存需要配合强缓存使用，如果不启用强缓存的话，协商缓存根本没有意义 大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】 但是下面的场景需要注意： 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）]]></content>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多种跨域方案详解]]></title>
    <url>%2Farticles%2F3222442466.html</url>
    <content type="text"><![CDATA[同源策略同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以 xyz.com 下的 js 脚本采用 ajax 读取 abc.com 里面的文件数据是会被拒绝的。 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 所谓同源是指：域名、协议、端口相同。 网址 结果 原因 https://yuwangi.github.io 成功 域名、协议、端口均相同 http://yuwangi.github.io 失败 协议不同 https://yuwangi.github.io:9001 失败 端口不同 https://smwang.github.io 失败 域名不同 为什么要有跨域限制因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。 如果浏览器没有同源策略，会存在什么样的安全问题呢。下面从 DOM 同源策略和 XMLHttpRequest 同源策略来举例说明： 如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击： 做一个假网站，里面用 iframe 嵌套一个银行网站 http://mybank.com把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。这时如果用户输入账号密码，我们的主网站可以跨域访问到 http://mybank.com 的 dom 节点，就可以拿到用户的账户密码了。如果 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击： 用户登录了自己的银行页面 http://mybank.com，http://mybank.com 向用户的 cookie 中添加用户标识。用户浏览了恶意页面 http://evil.com，执行了页面中的恶意 AJAX 请求代码。http://evil.com 向 http://mybank.com 发起 AJAX HTTP 请求，请求会默认把 http://mybank.com 对应 cookie 也同时发送过去。银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。而且由于 Ajax 在后台执行，用户无法感知这一过程。因此，有了浏览器同源策略，我们才能更安全的上网。 跨域解决方案 jsonp cors postMessage document.domain window.name location.hash http-proxy nginx websocket jsonp1234567891011121314151617181920212223242526272829303132//此处直接手写一个jsonpfunction jsonp(&#123; url, params, cb &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement("script"); window[cb] = function(data) &#123; resolve(data); document.body.removeChild(script); &#125;; params = &#123; ...params, cb &#125;; let arrs = []; for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join("&amp;")&#125;`; document.body.appendChild(script); &#125;);&#125;//只能发送get请求 不支持post put delect//不安全 xss攻击jsonp(&#123; url: "https://image.baidu.com/httpsjsonp/pc", //此处链接为百度搜索随便找的 params: &#123; callback: "imageCheckHttps", _: 1571021917647 &#125;, cb: "imageCheckHttps"&#125;).then(data =&gt; &#123; console.log(data);&#125;); cors12345678910111213141516171819202122232425262728//index.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello &lt;script&gt; let xhr = new XMLHttpRequest; xhr.open('GET', 'http://localhost:3001/getData', true); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; console.log(xhr.response) &#125; &#125; &#125; xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456//server.jsconst express = require("express");let app = express();app.use(express.static(__dirname));app.listen(3000); 12345678910111213141516171819//server2.jsconst express = require("express");let app = express();let whiteList = ["http://localhost:3000"];app.use(function(req, res, next) &#123; console.log(req.headers); let origin = req.headers.origin; if (whiteList.includes(origin)) &#123; //设置源 请求头 res.setHeader("Access-Control-Allow-Origin", origin); &#125; next();&#125;);app.get("/getData", function(req, res, next) &#123; console.log("req.headers", "111"); res.end("我不爱你");&#125;);app.use(express.static(__dirname));app.listen(3001); postMessage12345678910111213141516171819202122232425//a.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe id="frame" src="http://localhost:3001/b.html" frameborder="0" onload="load()"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:3001') window.onmessage = function (e) &#123; console.log(e.data) &#125; &#125;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819202122//b.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onmessage = function (e) &#123; console.log(e); console.log(e.data) e.source.postMessage('我不爱你', e.origin) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456// a server.jsconst express = require("express");let app = express();app.use(express.static(__dirname));app.listen(3000); 123456// b server.jsconst express = require("express");let app = express();app.use(express.static(__dirname));app.listen(3000); document.domain对于主域名相同，且协议，端口一致，而子域名不同的情况，可以使用 document.domain 来跨域。 12345//一级域名、二级域名//一级域名//iframe 引用二级域名//只需在两个域名设置 document.domain 为同一值 即可 window.name12345678910111213141516171819202122232425262728293031323334//a.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; //a和b是同域的 localhost:3000 //c 是独立的 localhost:3001 //a 获取c的值 //a先引用c c把值放到window.name 然后把a引用的地址改为b &lt;iframe id="iframe" src="http://localhost:3001/c.html" onload="load()" frameborder="0"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true; function load() &#123; let iframe = document.getElementById('iframe'); if (first) &#123; iframe.src = 'http://localhost:3000/b.html'; first = false; &#125; else &#123; console.log(iframe.contentWindow.name) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516//b.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718//c.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; Window.name = '我不爱你' &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456// server aconst express = require("express");let app = express();app.use(express.static(__dirname));app.listen(3000); 123456// server bconst express = require("express");let app = express();app.use(express.static(__dirname));app.listen(3001); location.hash12345678910111213141516171819202122232425//a.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src="http://localhost:3001/c.html#iloveyou" frameborder="0"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;script&gt; //路径后的hash是可以通信的 //目的：a想访问c的数据 // a给c传一个hash值 =&gt; c收到后 把hash值传递给b =&gt; b将结果放到a的hash值中 // a、b 同域 c不同域 window.onhashchange = function () &#123; console.log(location.hash) &#125;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819//b.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; window.parent.parent.location.hash = location.hash;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819202122//c.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; console.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe);&lt;/script&gt;&lt;/html&gt; 123456// a server.jsconst express = require("express");let app = express();app.use(express.static(__dirname));app.listen(3000); 123456// b server.jsconst express = require("express");let app = express();app.use(express.static(__dirname));app.listen(3001); http-proxy类似于 webpack 转发 123456789101112131415161718devServer: &#123; host: '0.0.0.0', port: 9001, headers: &#123; 'Access-Control-Allow-Origin': '*' &#125;, historyApiFallback: &#123; rewrites: [&#123; from: /.*/g, to: '/www/view/index.html' &#125;] &#125;, proxy: &#123; '/api': &#123; target: 'http://192.168.1.192:8091/' &#125; &#125; &#125; nginx首先需要先下载 nginx, http://nginx.org/en/download.html 12345//配置nginxlocation ~.*\.json &#123; root json;//转发文件放在 json文件夹下 add_header "Access-Control-Allow-Origin" "*";&#125; 12345678910111213141516171819202122232425262728//index.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let xhr = new XMLHttpRequest; xhr.open('GET', 'http://localhost:3001/getData', true); xhr.setRequestHeader('Access-Control-Allow-Origin', 'http://localhost:3001') xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; console.log(xhr.response) &#125; &#125; &#125; xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456//server.jsconst express = require("express");let app = express();app.use(express.static(__dirname));app.listen(3000); websocket123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //高阶api let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function () &#123; socket.send('我爱你') &#125; socket.onmessage = function (data) &#123; console.log(data.data) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011//server.jsconst express = require("express");let Websocket = require("ws");let app = express();let wss = new Websocket.Server(&#123; port: 3000 &#125;);wss.on("connection", function(ws) &#123; ws.on("message", function(data) &#123; console.log(data); ws.send("我不爱你"); &#125;);&#125;);]]></content>
      <tags>
        <tag>js</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0响应式原理]]></title>
    <url>%2Farticles%2F1320895259.html</url>
    <content type="text"><![CDATA[Vue2.0 版本相信大家已经用了很长时间了，但是知道它的工作原理是什么吗？下面就给大家介绍一下 Vue2.0 的原理]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue3.0响应式原理]]></title>
    <url>%2Farticles%2F2716464634.html</url>
    <content type="text"><![CDATA[10 月 5 日凌晨，Vue3.0 框架的作者兼核心开发者尤雨溪公布了尚处于 Pre-Alpha 状态的 Vue3.0 源码 https://github.com/vuejs/vue-next 体验首先打开上面源码地址，执行npm install,然后npm run dev或npm run build 上面标红的文件，就是 Vue3.0 预览版生成的文件。 首先感受一下预览版 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="./dist/vue.global.js"&gt;&lt;/script&gt; &lt;script &gt; const App = &#123; template: '&#123;&#123;count&#125;&#125;', data() &#123; return &#123; count: 1 &#125; &#125; &#125; let container = document.getElementById('app'); let _proxy = Vue.createApp().mount(App, container); setTimeout(() =&gt; &#123; _proxy.count = 100; console.log(_proxy) &#125;, 1000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到数据已经响应式变化,_proxy就是代理响应式数据侦测的对象 Proxy 如何实现响应数据变化Vue3.0 核心操作在 关于WeakMap的详解，可以参考后面的文章 ES6 Map、WeakMap详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//核心基于Proxy//Vue.reactiveconst toProxy = new WeakMap(); //存放代理后的对象const toRaw = new WeakMap(); //存放代理前的对象function trigger() &#123; console.log("触发视图更新");&#125;function isObject(target) &#123; return typeof target === "object" &amp;&amp; target != null;&#125;function reactive(target) &#123; if (!isObject(target)) &#123; return target; &#125; if (toProxy.get(target)) &#123; //如果代理表中已经存在了，就把当前结果返回 return toProxy.get(target); &#125; if (toRaw.has(target)) &#123; //如果对象已被代理过了,就把对象原封不动返回 return target; &#125; const handlers = &#123; //触发的方法 set(target, key, value, receiver) &#123; if (target.hasOwnProperty(key)) &#123; //只有是私有属性时，才会触发更新 trigger(); &#125; return Reflect.set(target, key, value, receiver); //https://www.jianshu.com/p/4a5eca0536c3 Reflect详解 &#125;, get(target, key, receiver) &#123; const res = Reflect.get(target, key, receiver); if (isObject(target[key])) &#123; //因为Proxy只能做一层代理，如果子元素还是对象，那么递归继续代理 return reactive(res); &#125; return res; &#125;, deleteProprety(target, key) &#123; return Reflect.deleteProprety(target, key); &#125; &#125;; let observed = new Proxy(target, handlers); toProxy.set(target, observed); //原对象 ：代理后结果 toRaw.set(observed, target); return observed;&#125;let obj = &#123; name: "yuwangi", ary: [1, 2, 3]&#125;;let _proxy = reactive(obj);_proxy.name = "hahah";console.log(obj);_proxy.ary.push(4);console.log(obj); 运行结果：]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组遍历方法及效率测试]]></title>
    <url>%2Farticles%2F341754589.html</url>
    <content type="text"><![CDATA[js 中遍历数组并不会改变原始数组的方法总共有 12 个: 1234ES5： forEach、every 、some、 filter、map、reduce、reduceRight、ES6： find、findIndex、keys、values、entries 方法forEach12345array.forEach(function(currentValue, index, arr), thisValue)// 回调函数的参数 //1. currentValue(必须),数组当前元素的值 //2. index(可选), 当前元素的索引值 //3. arr(可选),数组对象本身 关于 forEach()你要知道： 无法中途退出循环，只能用 return 退出本次回调，进行下一次回调。 它总是返回 undefined 值,即使你 return 了一个值。 12345678910111213let a = [1, 2, , 3]; // 第三个元素是空的，不会遍历(undefined、null会遍历)let obj = &#123; name: "OBKoro1" &#125;;let result = a.forEach(function(value, index, array) &#123; a[3] = "改变元素"; a.push("添加到尾端，不会被遍历"); console.log(value, "forEach传递的第一个参数"); // 分别打印 1 ,2 ,改变元素 console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上 // break; // break会报错 return value; // return只能结束本次回调 会执行下次回调 console.log("不会执行，因为return 会执行下一次循环回调");&#125;, obj);console.log(result); // 即使return了一个值,也还是返回undefined// 回调函数也接受接头函数写法 every 检测数组所有元素是否都符合判断条件12345array.every(function(currentValue, index, arr), thisValue)// 回调函数的参数 //1. currentValue(必须),数组当前元素的值 //2. index(可选), 当前元素的索引值 //3. arr(可选),数组对象本身 方法返回值规则: 如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true 12345678function isBigEnough(element, index, array) &#123; return element &gt;= 10; // 判断数组中的所有元素是否都大于10&#125;let result = [12, 5, 8, 130, 44].every(isBigEnough); // falselet result = [12, 54, 18, 130, 44].every(isBigEnough); // true// 接受箭头函数写法[12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); // false[12, 54, 18, 130, 44].every(x =&gt; x &gt;= 10); // true some 数组中的是否有满足判断条件的元素12345array.some(function(currentValue, index, arr), thisValue)// 回调函数的参数 //1. currentValue(必须),数组当前元素的值 //2. index(可选), 当前元素的索引值 //3. arr(可选),数组对象本身 方法返回值规则： 如果有一个元素满足条件，则表达式返回 true, 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回 false。 12345function isBigEnough(element, index, array) &#123; return element &gt;= 10; //数组中是否有一个元素大于 10&#125;let result = [2, 5, 8, 1, 4].some(isBigEnough); // falselet result = [12, 5, 8, 1, 4].some(isBigEnough); // true filter 过滤原始数组，返回新数组12345let new_array = arr.filter(function(currentValue, index, arr), thisArg)// 回调函数的参数 //1. currentValue(必须),数组当前元素的值 //2. index(可选), 当前元素的索引值 //3. arr(可选),数组对象本身 12345let a = [32, 33, 16, 40];let result = a.filter(function(value, index, array) &#123; return value &gt;= 18; // 返回a数组中所有大于18的元素&#125;);console.log(result, a); // [32,33,40] [32,33,16,40] map 对数组中的每个元素进行处理，返回新的数组12345let new_array = arr.map(function(currentValue, index, arr), thisArg)// 回调函数的参数 //1. currentValue(必须),数组当前元素的值 //2. index(可选), 当前元素的索引值 //3. arr(可选),数组对象本身 123456let a = ["1", "2", "3", "4"];let result = a.map(function(value, index, array) &#123; return value + "新数组的新元素";&#125;);console.log(result, a);// ["1新数组的新元素","2新数组的新元素","3新数组的新元素","4新数组的新元素"] ["1","2","3","4"] reduce 为数组提供累加器，合并为一个值123456array.reduce(function(total, currentValue, currentIndex, arr), initialValue) // 回调函数的参数 //1. total(必须)，初始值, 或者上一次调用回调返回的值 //2. currentValue(必须),数组当前元素的值 //3. index(可选), 当前元素的索引值 //4. arr(可选),数组对象本身 回调第一次执行时: 如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。 12345678// 数组求和let sum = [0, 1, 2, 3].reduce(function(a, b) &#123; return a + b;&#125;, 0);// 6// 将二维数组转化为一维 将数组元素展开let flattened = [[0, 1], [2, 3], [4, 5]].reduce((a, b) =&gt; a.concat(b), []);// [0, 1, 2, 3, 4, 5] reduceRight 从右至左累加这个方法除了与 reduce 执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。 ES6：find()&amp; findIndex() 根据条件找到数组成员find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined。 findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123456let new_array = arr.find(function(currentValue, index, arr), thisArg)let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)// 回调函数的参数 //1. currentValue(必须),数组当前元素的值 //2. index(可选), 当前元素的索引值 //3. arr(可选),数组对象本身 这两个方法都可以识别 NaN,弥补了 indexOf 的不足. 12345678// findlet a = [1, 4, -5, 10].find(n =&gt; n &lt; 0); // 返回元素-5let b = [1, 4, -5, 10, NaN].find(n =&gt; Object.is(NaN, n)); // 返回元素NaNlet c = [1, 4, -5, 10].find(n =&gt; Object.is(NaN, n)); // 返回undefined// findIndexlet a = [1, 4, -5, 10].findIndex(n =&gt; n &lt; 0); // 返回索引2let b = [1, 4, -5, 10, NaN].findIndex(n =&gt; Object.is(NaN, n)); // 返回索引4let c = [1, 4, -5, 10].findIndex(n =&gt; n &gt; 10); // 返回索引-1 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值1234567891011121314151617for (let index of ["a", "b"].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ["a", "b"].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ["a", "b"].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 在 for..of 中如果遍历中途要退出，可以使用 break 退出循环。 如果不使用 for…of 循环，可以手动调用遍历器对象的 next 方法，进行遍历: 效率js 有如下两种数据需要经常遍历 数组(Array) 对象(Object) 同时又提供了如下 8 种方法方便我们遍历元素 for while(或 do~while) forEach for in map every 最终我们将分析遍历效率选出最佳遍历选手. 数组循环1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var array = [], length = (array.length = 10000000); //(一千万)// for(var i=0;i&lt;length;i++)&#123;// array[i] = 'louis';// &#125;// console.log(array[0]);//-------------------------forvar t1 = +new Date();for (var i = 0; i &lt; length; i++) &#123;&#125;var t2 = +new Date();console.log("for:" + (t2 - t1));//-------------------------do/whilevar t1 = +new Date();var i = 0;do &#123; i++;&#125; while (i &lt; length);var t2 = +new Date();console.log("do while:" + (t2 - t1));//-------------------------forEachvar t1 = +new Date();array.forEach(function(item) &#123;&#125;);var t2 = +new Date();console.log("forEach:" + (t2 - t1));//-------------------------for invar t1 = +new Date();for (var item in array) &#123;&#125;var t2 = +new Date();console.log("for in:" + (t2 - t1));//------------------------- everyvar t1 = +new Date();array.every(() =&gt; &#123;&#125;);var t2 = +new Date();console.log("every" + (t2 - t1));//------------------------- somevar t1 = +new Date();array.some(() =&gt; &#123;&#125;);var t2 = +new Date();console.log("some" + (t2 - t1));//-------------------------mapvar t1 = +new Date();array.map(function(num) &#123;&#125;);var t2 = +new Date();console.log("map:" + (t2 - t1));//-------------------------filtervar t1 = +new Date();array.filter(function(e, i, arr) &#123;&#125;);var t2 = +new Date();console.log("filter:" + (t2 - t1));//-------------------------reducevar t1 = +new Date();array.reduce(function(e, i, arr) &#123;&#125;);var t2 = +new Date();console.log("reduce:" + (t2 - t1)); 所以最终结果 1、for 与 do while 2、forEach map some every filter (这 5 个不相上下,可认为运行速度差不多) 3、for in (多次运行不稳定) 对象循环12345678910111213141516171819202122232425262728293031var array = [], length = (array.length = 10000000); //(一千万)var objects = &#123;&#125;;for (var i = 0; i &lt; array.length; i++) &#123; objects[i] = Math.random();&#125;//-------------------------for invar t1 = +new Date();for (var attr in objects) &#123;&#125;var t2 = +new Date();console.log("for in:" + (t2 - t1));//-------------------------Object.keysvar t1 = +new Date();Object.keys(objects);var t2 = +new Date();console.log("Object.keys" + (t2 - t1));//-------------------------Object.valuesvar t1 = +new Date();Object.values(objects);var t2 = +new Date();console.log("Object.values" + (t2 - t1));//-------------------------Object.getOwnPropertyNamesvar t1 = +new Date();Object.getOwnPropertyNames(objects);var t2 = +new Date();console.log("Object.getOwnPropertyNames" + (t2 - t1)); 结果出乎意料 1、Object.values 2、Object.keys、for in 3、Object.getOwnPropertyNames]]></content>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[惰性载入函数]]></title>
    <url>%2Farticles%2F3094046573.html</url>
    <content type="text"><![CDATA[惰性函数表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。本文将详细介绍惰性函数 使用背景因为各浏览器之间的行为的差异，经常会在函数中包含了大量的 if 语句，以检查浏览器特性，解决不同浏览器的兼容问题。比如，最常见的为 dom 节点添加事件的函数 123456789function addEvent(type, element, fun) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fun, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, fun); &#125; else &#123; element["on" + type] = fun; &#125;&#125; 每次调用 addEvent 函数的时候，它都要对浏览器所支持的能力进行检查，首先检查是否支持 addEventListener 方法，如果不支持，再检查是否支持 attachEvent 方法，如果还不支持，就用 dom0 级的方法添加事件 这个过程，在 addEvent 函数每次调用的时候都要走一遍，其实，如果浏览器支持其中的一种方法，那么它就会一直支持了，就没有必要再进行其他分支的检测了。也就是说，if 语句不必每次都执行，代码可以运行的更快一些 解决方案就是惰性载入 函数重写在介绍惰性函数之前，首先介绍函数重写技术。由于一个函数可以返回另一个函数，因此可以用新的函数来覆盖旧的函数 123456function a() &#123; console.log("a"); a = function() &#123; console.log("b"); &#125;;&#125; 这样一来，第一次调用该函数时会 console.log(‘a’)会被执行；全局变量 a 被重定义，并被赋予新的函数。当该函数再次被调用时， console.log(‘b’)会被执行 惰性函数惰性函数的本质就是函数重写。所谓惰性载入，指函数执行的分支只会发生一次，有两种实现惰性载入的方式 第一种是在函数被调用时，再处理函数。函数在第一次调用时，该函数会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。代码重写如下 12345678910111213141516function addEvent(type, element, fun) &#123; if (element.addEventListener) &#123; addEvent = function(type, element, fun) &#123; element.addEventListener(type, fun, false); &#125;; &#125; else if (element.attachEvent) &#123; addEvent = function(type, element, fun) &#123; element.attachEvent("on" + type, fun); &#125;; &#125; else &#123; addEvent = function(type, element, fun) &#123; element["on" + type] = fun; &#125;; &#125; return addEvent(type, element, fun);&#125; 在这个惰性载入的 addEvent()中，if 语句的每个分支都会为 addEvent 变量赋值，有效覆盖了原函数。最后一步便是调用了新赋函数。下一次调用 addEvent()时，便会直接调用新赋值的函数，这样就不用再执行 if 语句了但是，这种方法有个缺点，如果函数名称有所改变，修改起来比较麻烦 第二种是声明函数时就指定适当的函数。把嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就立刻进行一次判断，以便让 addEvent 返回一个包裹了正确逻辑的函数 123456789101112131415var addEvent = (function() &#123; if (document.addEventListener) &#123; return function(type, element, fun) &#123; element.addEventListener(type, fun, false); &#125;; &#125; else if (document.attachEvent) &#123; return function(type, element, fun) &#123; element.attachEvent("on" + type, fun); &#125;; &#125; else &#123; return function(type, element, fun) &#123; element["on" + type] = fun; &#125;; &#125;&#125;)(); 惰性函数应用12345678910111213141516171819202122232425262728293031323334function createXHR() &#123; var xhr = null, flag = false, ary = [ function() &#123; return new XMLHttpRequest(); &#125;, function() &#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125;, function() &#123; return new ActiveXObject("Msxml2.XMLHTTP"); &#125;, function() &#123; return new ActiveXObject("Msxml3.XMLHTTP"); &#125; ]; //循环遍历这个数组，看看数组内的哪一个元素兼容浏览器，如果兼容，就赋值给给xhr，并且返回出去 for (var i = 0, len = ary.length; i &lt; len; i++) &#123; var curFn = ary[i]; try &#123; xhr = curFn(); createXHR = curFn; //重新定义createXHR ,第二次调用ajax请求，则直接使用这个方法 flag = true; break; &#125; catch (e) &#123; //说明浏览器不兼容，继续循环 &#125; &#125; if (!flag) &#123; throw new Error("你的浏览器不支持 ，请升级浏览器"); &#125; return xhr;&#125;]]></content>
      <tags>
        <tag>js</tag>
        <tag>函数</tag>
        <tag>高阶程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中.sync 修饰符：进行父子组件间相互传递数据]]></title>
    <url>%2Farticles%2F3679178790.html</url>
    <content type="text"><![CDATA[.sync 修饰符的作用？允许 prop 进行双向绑定，以 this.$emit(update:PropName,newValue)的模式触发事件。 就是： 1&lt;text-document v-bind:title.sync="doc.title"&gt;&lt;/text-document&gt; 相当于： 1234&lt;text-document v-bind:title="doc.title" v-on:update:title="doc.title = $event"&gt;&lt;/text-document&gt; 以在index.vue下引入childrenOne子组件为例，使用.sync属性，会在mounted生命周期里面 alert 弹出childrenOne，而不是index。 123456789101112131415161718192021222324&lt;template&gt; &lt;div class="vuexWrap common"&gt; &lt;childrenOne :title.sync="doc.title"&gt;&lt;/childrenOne&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt; import childrenOne from '../../components/childrenOne.vue' export default&#123; data () &#123; return &#123; doc:&#123; title:'index' &#125;, &#125; &#125;, mounted ()&#123; //childrenOne alert(this.doc.title); &#125;, components : &#123; childrenOne &#125; &#125;&lt;/script&gt; 在childrenOne.vue的生命周期 mounted 里面通过this.$emit(&#39;update:title&#39;, this.newTitle);设置title属值 1234567891011121314151617181920&lt;template&gt; &lt;div class="OneWrap common"&gt; &#123;&#123;title&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt; export default&#123; props:&#123; title:"" &#125;, data () &#123; return &#123; newTitle:"childrenOne" &#125; &#125;, mounted ()&#123; this.$emit('update:title', this.newTitle); &#125;, &#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git开发规范]]></title>
    <url>%2Farticles%2F269865436.html</url>
    <content type="text"><![CDATA[分支管理 首先master和dev分支设置提交权限，只有项目管理员能提交 开发时在dev分支下拉取最新的代码，建立feature/aaa分支 进入git.code进行merge code view merge到dev分支 release分支 -(预上线分支) dev分支上测试环境 master上正式环境 每个版本打tag 提交规范 feat: 添加新特性 fix: 修复bug docs: 仅仅修改了文档 style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 refactor: 代码重构，没有加新功能或者修复bug perf: 增加代码进行性能测试 test: 增加测试用例 chore: 改变构建流程、或者增加依赖库、工具等 推荐一个git提交规范风格配置 https://www.conventionalcommits.org/en/v1.0.0-beta.4/ 安装 1npm install --save-dev commitizen cz-conventional-changelog @commitlint/cli @commitlint/config-conventional husky standard-version 配置package.json 1234567891011&#123; "scripts": &#123; "commit": "git-cz", "release": "standard-version" &#125;, "husky": &#123; "hooks": &#123; "commit-msg": "commitlint -E HUSKY_GIT_PARAMS" &#125; &#125;,&#125; 项目根新建 commitlint.config.js 123module.exports = &#123; extends: ['@commitlint/config-conventional']&#125;]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由守卫与登陆权限控制]]></title>
    <url>%2Farticles%2F557616484.html</url>
    <content type="text"><![CDATA[Vue 路由守卫路由守卫，也可以是路由拦截，我们可以通过路由拦截，来判断用户是否登录，该页面用户是否有权限浏览，需要结合 meta 来实现Vue 中路由守卫一共有三种，一个全局路由守卫，一个是组件内路由守卫，一个是 router 独享守卫 全局路由守卫所谓全局守卫就是所有页面的路由拦截。它有两个钩子 全局前置守卫beforeEach, 全局后置守卫afterEach 全局前置守卫，就是 用户进入页面时路由拦截，进行一些处理的钩子。通常做一些页面权限控制或 title 命名之类的操作。 全局后置守卫，就是 页面成功访问的回调钩子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import Vue from "vue";import VueRouter from "vue-router";// Vue中插件必须use注册Vue.use(VueRouter);// 路由配置项，此处是路由级钩子的定义const routes = [ &#123; path: "/", component: resolve =&gt; require(["./index.vue"], resolve), keepAlive: true &#125;, &#123; path: "/user/:userName", keepAlive: true, beforeEnter(to, from, next) &#123; console.log("router beforeEnter"); next(); &#125;, component: resolve =&gt; require(["./user.vue"], resolve) &#125;];// 实例化路由对象const router = new VueRouter(&#123; routes&#125;);// 全局钩子router.beforeEach((to, from, next) =&gt; &#123; // to: Route: 即将要进入的目标 路由对象 // from: Route: 当前导航正要离开的路由 // next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 console.log("global beforeEach"); next();&#125;);router.beforeResolve((to, from, next) =&gt; &#123; console.log("global beforeResolve"); next();&#125;);router.afterEach((to, from, next) =&gt; &#123; console.log("global afterEach");&#125;);// 实例化Vue对象并挂载new Vue(&#123; router&#125;).$mount("#app"); 组件独享守卫组件独享守卫是加载组件时定义的一些钩子，有beforeRouteEnter、beforeRouteUpdate和beforeRouteLeave 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;p&gt;我是:&#123;&#123;userName&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'user', data () &#123; return &#123; msg: '这里是 User Page.', userName: 'yuwangi' &#125;; &#125;, methods: &#123;&#125;, mounted () &#123; var me = this; me.userName = me.$route.params.userName; console.log('user mounted.'); &#125;, beforeRouteEnter (to, from, next) &#123;//组件激活 console.log('component beforeRouteEnter'); next(); &#125;, beforeRouteUpdate (to, from, next) &#123;//在当前路由改变，但是该组件被复用时调用 console.log('component beforeRouteUpdate'); next(); &#125;, beforeRouteLeave(to,from,next)&#123;// 导航离开该组件的对应路由时调用 console.log('component beforeRouteLeave'); next(); &#125; &#125;;&lt;/script&gt; 登陆权限控制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import Vue from "vue";import Element from "element-ui";import "./assets/eletheme/index.css";import router from "./router/index";import store from "./store/index";import App from "./Index.vue";import NProgress from "vue-nprogress"; //加载进度条// import * as filters from './filters';import * as directives from "./directive";Vue.use(Element, &#123; size: "small" &#125;);Vue.use(NProgress, &#123;&#125;);const nprogress = new NProgress(&#123; parent: ".app-nprogress" &#125;);// // 全局过滤器// Object.keys(filters).forEach(key =&gt; &#123;// Vue.filter(key, filters[key]);// &#125;);// 全局指令Object.keys(directives).forEach(key =&gt; &#123; Vue.directive(key, directives[key]);&#125;);// 路由守卫router.beforeEach((to, from, next) =&gt; &#123; // 时间统计 if (window._Timer) &#123; window._Timer[to.path] = window._Timer.now(); &#125; // 登录或者未登录跳转 const randerPath = isLogin =&gt; &#123; const firstPath = to.path.split("/")[1]; console.log("&gt; isLogin", isLogin); // 未登录操作 if (!isLogin) &#123; if (firstPath !== "login") &#123; // 根目录过来的不添加参数 if (to.fullPath === "/") &#123; next(&#123; path: "/login" &#125;); &#125; else &#123; next(&#123; path: "/login" // query: &#123; redirect: to.fullPath &#125; &#125;); &#125; &#125; else &#123; next(); &#125; &#125; else &#123; if (firstPath === "login") &#123; next("/"); &#125; else &#123; next(); &#125; &#125; &#125;; randerPath(window.serverData.isLogin);&#125;);router.afterEach(to =&gt; &#123; if (window._Timer &amp;&amp; !window._Timer.inited) &#123; const now = parseInt(window._Timer.now() - window._Timer.start, 10); // window.console.log('topath:', to.path); // window.console.timeEnd('firstRouter'); window._Timer.tjTrack("timing", "router", "firstRouter", now); window._Timer.inited = true; &#125;&#125;);// 挂载vue实例const app = new Vue(&#123; router, store, nprogress, ...App&#125;);app.$mount("#App");]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>router</tag>
        <tag>权限控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯子免费上网攻略]]></title>
    <url>%2Farticles%2F2729354182.html</url>
    <content type="text"><![CDATA[本篇文章分享一些科学上网 Shadowsocks、ShadowsocksR、V2Ray、Brook、Goflyway 等代理方式。为了方便访问 Google 查阅资料而设，请勿用于任何非法活动（请遵守中国法律）。部分账号信息由网友贡献分享，在此感谢！ 电脑 第一种、chrome 浏览器插件 setup VPN资源链接: https://pan.baidu.com/s/1gtA3D7DVT180hXP7ViIAUA 提取码: x1y2（如不能使用，请邮件联系） 操作步骤：1、打开 chrome 浏览器2、工具栏 …3、更多工具4、扩展程序5、把下载下来的资源拖放到窗口6、启用扩展程序7、注册邮箱账号8、点击选用不同国家地区使用 第二种、windows 软件 链接: https://pan.baidu.com/s/1ppp9SPhhQ1O1LU4GfVAeKg 提取码: zxk8 安装完需要配置 ssr(由于 ssr 不定期更新),有需求的请在关于页面加我联系方式(免费的哦~) 苹果手机苹果手机由于app store限制,无法下载代理软件。特此分享一个免费的美区 ID。账号：gd5@jufxf.com，密码：Macziyuan.com2018,禁止将此账号分享给其他人。Tips:账号如不能使用建议自己注册一个 攻略：https://www.hurbai.com/iOS/60 1、手机打开设置2、Apple ID、iCloud、iTunes 等3、iTunes Store 与 App Store4、选中 Apple ID 退出登陆5、登陆提供的账号6、在 app store 中搜索 Shadowrocket 并下载 此处介绍几个免费 SSR 账号网址https://chenxinbo.com/freehttps://free-ss.site/https://lncn.org/ 使用方法很简单，里面提供了一些 ss 链接或者二维码，打开下载的软件直接使用即可。 安卓手机直接下载 Shadowrocket 软件，然后通过前边分享的 SSR 账号直接使用即可。 https://github.com/shadowsocksrr/shadowsocksr-android/releases/download/3.5.4/shadowsocksr-android-3.5.4.apk]]></content>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局详解及实战]]></title>
    <url>%2Farticles%2F2516740711.html</url>
    <content type="text"><![CDATA[Flex 布局是什么Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display:flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display:inline-flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction(方向)flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap (换行) 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;//数值&#125; flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; Flex练习阮一峰老师做了个骰子练习，那么我也就着手做一个。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;骰子练习&lt;/title&gt; &lt;style&gt; body,html&#123; background: #ccc; &#125; .box&#123; width: 160px; height: 160px; display: flex; justify-content:center; align-items: center; align-content:space-around; background: #fff; border-radius: 5px; &#125; .item&#123; background: #ff0000; width: 34px; height: 34px; border-radius: 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;骰子练习&lt;/title&gt; &lt;style&gt; body,html&#123; background: #ccc; &#125; .box&#123; width: 160px; height: 160px; display: flex; flex-direction:column; /* 纵向排列 */ justify-content:space-around; /* 子元素 间隔相同 */ align-items: center; /* 纵轴居中 */ background: #fff; border-radius: 5px; &#125; .item&#123; background: #ff0000; width: 34px; height: 34px; border-radius: 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;骰子练习&lt;/title&gt; &lt;style&gt; body,html&#123; background: #ccc; &#125; .box&#123; width: 160px; height: 160px; display: flex; flex-direction:column; align-items: center; justify-content: space-around; background: #fff; border-radius: 5px; &#125; .item&#123; background: #ff0000; width: 34px; height: 34px; border-radius: 50%; &#125; .item1&#123; align-self: flex-start; justify-content: space-around; &#125; .item2&#123; justify-content: center; align-self: center; &#125; .item3&#123; align-self: flex-end; justify-content: space-around; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="item item1"&gt;&lt;/div&gt; &lt;div class="item item2"&gt;&lt;/div&gt; &lt;div class="item item3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>Flex</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eslint规范]]></title>
    <url>%2Farticles%2F1289082893.html</url>
    <content type="text"><![CDATA[ESLintESLint是一个语法规则和代码风格的检查工具。 问题1、由于javascript是一门弱语言，代码规范不严格，会造成一些问题。 123//有些人习惯加分号，有些人则不加，但在特殊情况下不加会出现语法错误 例如 use strict 、typescriptlet a=0;let b=1 2、编码过后运行在浏览器出现各种报错。 3、在团队git开发合作中，由于VSCode中代码格式化工具繁多，不同工具格式化造成的影响。（此处参照上一篇VSCode配置） 以下规则沿用腾讯AlloyTeam ESLint 规范，而且也是你也可以配置个性化 ESLint 规则安装1npm install --save-dev eslint babel-eslint vue-eslint-parser@5.0.0 eslint-plugin-vue eslint-config-alloy 配置原则我们依据以下三条原则，研读了 ESLint 所有的配置项，定制出了心目中的「完美」ESLint 配置。1、能够帮助发现代码错误的规则，全部开启配置2、不应该依赖于某个具体项目，而应尽可能的合理3、帮助保持团队的代码风格统一，而不是限制开发体验 在你的项目根目录下创建 .eslintrc.js，并将以下内容复制到文件中： 12345678910111213141516171819202122232425module.exports = &#123; extends: [ 'alloy', 'alloy/vue', ], env: &#123; // 这里填入你的项目用到的环境 // 它们预定义了不同环境的全局变量，比如： // // browser: true, // node: true, // mocha: true, // jest: true, // jquery: true &#125;, globals: &#123; // 这里填入你的项目需要的全局变量 // false 表示这个全局变量不允许被重新赋值，比如： // // myGlobal: false &#125;, rules: &#123; // 这里填入你的项目需要的个性化配置 &#125;&#125;; 附件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110module.exports = &#123; extends: ['./base.js'], rules: &#123; /** * 禁止 for 循环出现方向错误的循环 * @category Possible Errors */ 'for-direction': 'error', /** * getter 必须有返回值，并且禁止返回空 * @category Possible Errors */ 'getter-return': [ 'error', &#123; allowImplicit: false &#125; ], /** * 禁止将 async 函数做为 new Promise 的回调函数 * @category Possible Errors * @reason 出现这种情况时，一般不需要使用 new Promise 实现异步了 */ 'no-async-promise-executor': 'error', /** * 禁止将 await 写在循环里，因为这样就无法同时发送多个异步请求了 * @category Possible Errors * @reason 要求太严格了，有时需要在循环中写 await */ 'no-await-in-loop': 'off', /** * 禁止与负零进行比较 * @category Possible Errors */ 'no-compare-neg-zero': 'error', /** * 禁止在测试表达式中使用赋值语句，除非这个赋值语句被括号包起来了 * @category Possible Errors */ 'no-cond-assign': ['error', 'except-parens'], /** * 禁止使用 console * @category Possible Errors * @reason console 的使用很常见 */ 'no-console': 'off', /** * 禁止将常量作为分支条件判断中的测试表达式，但允许作为循环条件判断中的测试表达式 * @category Possible Errors */ 'no-constant-condition': [ 'error', &#123; checkLoops: false &#125; ], /** * 禁止在正则表达式中出现 Ctrl 键的 ASCII 表示，即禁止使用 /\x1f/ * @category Possible Errors * @reason 几乎不会遇到这种场景 */ 'no-control-regex': 'off', /** * 禁止使用 debugger * @category Possible Errors */ 'no-debugger': 'error', /** * 禁止在函数参数中出现重复名称的参数 * @category Possible Errors * @reason 在编译阶段就会报错了 */ 'no-dupe-args': 'off', /** * 禁止在对象字面量中出现重复名称的键名 * @category Possible Errors */ 'no-dupe-keys': 'error', /** * 禁止在 switch 语句中出现重复测试表达式的 case * @category Possible Errors */ 'no-duplicate-case': 'error', /** * 禁止出现空代码块，允许 catch 为空代码块 * @category Possible Errors */ 'no-empty': [ 'error', &#123; allowEmptyCatch: true &#125; ], /** * 禁止在正则表达式中使用空的字符集 [] * @category Possible Errors */ 'no-empty-character-class': 'error', /** * 禁止将 catch 的第一个参数 error 重新赋值 * @category Possible Errors */ 'no-ex-assign': 'error', /** * 禁止不必要的布尔类型转换，比如 !! 或 Boolean * @category Possible Errors */ 'no-extra-boolean-cast': 'error', /** * 禁止将一个函数声明重新赋值 * @category Possible Errors */ 'no-func-assign': 'error', /** * 禁止在 if 代码块内出现函数声明 * @category Possible Errors */ 'no-inner-declarations': ['error', 'both'], /** * 禁止在 RegExp 构造函数中出现非法的正则表达式 * @category Possible Errors */ 'no-invalid-regexp': 'error', /** * 禁止使用特殊空白符（比如全角空格），除非是出现在字符串、正则表达式或模版字符串中 * @category Possible Errors */ 'no-irregular-whitespace': [ 'error', &#123; skipStrings: true, skipComments: false, skipRegExps: true, skipTemplates: true &#125; ], /** * 禁止正则表达式中使用肉眼无法区分的特殊字符 * @category Possible Errors * @reason 某些特殊字符很难看出差异，最好不要在正则中使用 */ 'no-misleading-character-class': 'error', /** * 禁止将 Math, JSON 或 Reflect 直接作为函数调用 * @category Possible Errors */ 'no-obj-calls': 'error', /** * 禁止使用 hasOwnProperty, isPrototypeOf 或 propertyIsEnumerable * @category Possible Errors * @reason hasOwnProperty 比较常用 */ 'no-prototype-builtins': 'off', /** * 禁止在正则表达式中出现连续的空格，必须使用 /foo &#123;3&#125;bar/ 代替 * @category Possible Errors */ 'no-regex-spaces': 'error', /** * 禁止在数组中出现连续的逗号 * @category Possible Errors */ 'no-sparse-arrays': 'error', /** * 禁止在普通字符串中出现模版字符串里的变量形式 * @category Possible Errors */ 'no-template-curly-in-string': 'error', /** * 禁止在 return, throw, break 或 continue 之后还有代码 * @category Possible Errors */ 'no-unreachable': 'error', /** * 禁止在 finally 中出现 return, throw, break 或 continue * @category Possible Errors * @reason finally 中的语句会在 try 之前执行 */ 'no-unsafe-finally': 'error', /** * 禁止在 in 或 instanceof 操作符的左侧使用感叹号，如 if (!key in object) * @category Possible Errors */ 'no-unsafe-negation': 'error', /** * 禁止将 await 或 yield 的结果做为运算符的后面项 * https://github.com/eslint/eslint/issues/11899 * 在上面 issue 修复之前，关闭此规则 * @category Possible Errors * @reason 这样会导致不符合预期的结果 */ 'require-atomic-updates': 'off', /** * 必须使用 isNaN(foo) 而不是 foo === NaN * @category Possible Errors */ 'use-isnan': 'error', /** * typeof 表达式比较的对象必须是 'undefined', 'object', 'boolean', 'number', 'string', 'function', 'symbol', 或 'bigint' * @category Possible Errors */ 'valid-typeof': 'error', /** * setter 必须有对应的 getter，getter 可以没有对应的 setter * @category Best Practices */ 'accessor-pairs': [ 'error', &#123; setWithoutGet: true, getWithoutSet: false &#125; ], /** * 数组的方法除了 forEach 之外，回调函数必须有返回值 * @category Best Practices */ 'array-callback-return': 'error', /** * 将 var 定义的变量视为块作用域，禁止在块外使用 * @category Best Practices * @reason 已经禁止使用 var 了 */ 'block-scoped-var': 'off', /** * 在类的非静态方法中，必须存在对 this 的引用 * @category Best Practices */ 'class-methods-use-this': 'off', /** * 禁止函数的循环复杂度超过 20 * @category Best Practices * @reason https://en.wikipedia.org/wiki/Cyclomatic_complexity */ complexity: [ 'error', &#123; max: 20 &#125; ], /** * 禁止函数在不同分支返回不同类型的值 * @category Best Practices * @reason 缺少 TypeScript 的支持，类型判断是不准确的 */ 'consistent-return': 'off', /** * switch 语句必须有 default * @category Best Practices */ 'default-case': 'off', /** * 禁止出现 foo['bar']，必须写成 foo.bar * @category Best Practices * @reason 当需要写一系列属性的时候，可以更统一 */ 'dot-notation': 'off', /** * 必须使用 === 或 !==，禁止使用 == 或 != * @category Best Practices */ eqeqeq: ['error', 'always'], /** * for in 内部必须有 hasOwnProperty * @category Best Practices */ 'guard-for-in': 'error', /** * 限制一个文件中类的数量 * @category Best Practices */ 'max-classes-per-file': 'off', /** * 禁止使用 alert * @category Best Practices * @reason alert 很常用 */ 'no-alert': 'off', /** * 禁止使用 caller 或 callee * @category Best Practices * @reason 它们是已废弃的语法 */ 'no-caller': 'error', /** * switch 的 case 内有变量定义的时候，必须使用大括号将 case 内变成一个代码块 * @category Best Practices */ 'no-case-declarations': 'error', /** * 禁止在正则表达式中出现形似除法操作符的开头，如 let a = /=foo/ * @category Best Practices * @reason 有代码高亮的话，在阅读这种代码时，也完全不会产生歧义或理解上的困难 */ 'no-div-regex': 'off', /** * 禁止在 else 内使用 return，必须改为提前结束 * @category Best Practices * @reason else 中使用 return 可以使代码结构更清晰 */ 'no-else-return': 'off', /** * 不允许有空函数 * @category Best Practices * @reason 有时需要将一个空函数设置为某个项的默认值 */ 'no-empty-function': 'off', /** * 禁止解构赋值中出现空 &#123;&#125; 或 [] * @category Best Practices */ 'no-empty-pattern': 'error', /** * 禁止使用 foo == null，必须使用 foo === null * @category Best Practices */ 'no-eq-null': 'error', /** * 禁止使用 eval * @category Best Practices */ 'no-eval': 'error', /** * 禁止修改原生对象 * @category Best Practices * @reason 修改原生对象可能会与将来版本的 js 冲突 */ 'no-extend-native': 'error', /** * 禁止出现没必要的 bind * @category Best Practices */ 'no-extra-bind': 'error', /** * 禁止出现没必要的 label * @category Best Practices * @reason 已经禁止使用 label 了 */ 'no-extra-label': 'off', /** * switch 的 case 内必须有 break, return 或 throw，空的 case 除外 * @category Best Practices */ 'no-fallthrough': 'error', /** * 禁止对全局变量赋值 * @category Best Practices */ 'no-global-assign': 'error', /** * 禁止使用 !! ~ 等难以理解的运算符，仅允许使用 !! * @category Best Practices */ 'no-implicit-coercion': [ 'error', &#123; allow: ['!!'] &#125; ], /** * 禁止在全局作用域下定义变量或申明函数 * @category Best Practices * @reason 模块化之后，不会出现这种在全局作用域下定义变量的情况 */ 'no-implicit-globals': 'off', /** * 禁止在 setTimeout 或 setInterval 中传入字符串 * @category Best Practices */ 'no-implied-eval': 'error', /** * 禁止在类之外的地方使用 this * @category Best Practices * @reason 只允许在 class 中使用 this */ 'no-invalid-this': 'error', /** * 禁止使用 __iterator__ * @category Best Practices * @reason __iterator__ 是一个已废弃的属性 */ 'no-iterator': 'error', /** * 禁止使用 label * @category Best Practices */ 'no-labels': 'error', /** * 禁止使用没必要的 &#123;&#125; 作为代码块 * @category Best Practices */ 'no-lone-blocks': 'error', /** * 禁止在循环内的函数中出现循环体条件语句中定义的变量 * @category Best Practices * @reason 使用 let 就已经解决了这个问题了 */ 'no-loop-func': 'off', /** * 禁止使用 magic numbers * @category Best Practices */ 'no-magic-numbers': 'off', /** * 禁止使用 \ 来换行字符串 * @category Best Practices */ 'no-multi-str': 'error', /** * 禁止直接 new 一个类而不赋值 * @category Best Practices * @reason new 应该作为创建一个类的实例的方法，所以不能不赋值 */ 'no-new': 'error', /** * 禁止使用 new Function * @category Best Practices * @reason 这和 eval 是等价的 */ 'no-new-func': 'error', /** * 禁止使用 new 来生成 String, Number 或 Boolean * @category Best Practices */ 'no-new-wrappers': 'error', /** * 禁止使用 0 开头的数字表示八进制数 * @category Best Practices */ 'no-octal': 'error', /** * 禁止使用八进制的转义符 * @category Best Practices */ 'no-octal-escape': 'error', /** * 禁止对函数的参数重新赋值 * @category Best Practices */ 'no-param-reassign': 'error', /** * 禁止使用 __proto__ * @category Best Practices */ 'no-proto': 'error', /** * 禁止重复定义变量 * @category Best Practices */ 'no-redeclare': 'error', /** * 禁止使用指定的对象属性 * @category Best Practices * @reason 它用于限制某个具体的 api 不能使用 */ 'no-restricted-properties': 'off', /** * 禁止在 return 语句里赋值 * @category Best Practices */ 'no-return-assign': ['error', 'always'], /** * 禁止在 return 语句里使用 await * @category Best Practices */ 'no-return-await': 'error', /** * 禁止出现 location.href = 'javascript:void(0)'; * @category Best Practices * @reason 有些场景下还是需要用到这个 */ 'no-script-url': 'off', /** * 禁止将自己赋值给自己 * @category Best Practices */ 'no-self-assign': 'error', /** * 禁止将自己与自己比较 * @category Best Practices */ 'no-self-compare': 'error', /** * 禁止使用逗号操作符 * @category Best Practices */ 'no-sequences': 'error', /** * 禁止 throw 字面量，必须 throw 一个 Error 对象 * @category Best Practices */ 'no-throw-literal': 'error', /** * 循环内必须对循环条件的变量有修改 * @category Best Practices */ 'no-unmodified-loop-condition': 'error', /** * 禁止无用的表达式 * @category Best Practices */ 'no-unused-expressions': [ 'error', &#123; allowShortCircuit: true, allowTernary: true, allowTaggedTemplates: true &#125; ], /** * 禁止出现没用到的 label * @category Best Practices * @reason 已经禁止使用 label 了 */ 'no-unused-labels': 'off', /** * 禁止出现没必要的 call 或 apply * @category Best Practices */ 'no-useless-call': 'error', /** * 禁止在 catch 中仅仅只是把错误 throw 出去 * @category Best Practices * @reason 这样的 catch 是没有意义的，等价于直接执行 try 里的代码 */ 'no-useless-catch': 'error', /** * 禁止出现没必要的字符串连接 * @category Best Practices */ 'no-useless-concat': 'error', /** * 禁止出现没必要的转义 * @category Best Practices * @reason 转义可以使代码更易懂 */ 'no-useless-escape': 'off', /** * 禁止没必要的 return * @category Best Practices * @reason 没必要限制 return */ 'no-useless-return': 'off', /** * 禁止使用 void * @category Best Practices */ 'no-void': 'error', /** * 禁止注释中出现 TODO 和 FIXME * @category Best Practices * @reason TODO 很常用 */ 'no-warning-comments': 'off', /** * 禁止使用 with * @category Best Practices */ 'no-with': 'error', /** * 使用 ES2018 中的正则表达式命名组 * @category Best Practices * @reason 正则表达式已经较难理解了，没必要强制加上命名组 */ 'prefer-named-capture-group': 'off', /** * Promise 的 reject 中必须传入 Error 对象，而不是字面量 * @category Best Practices */ 'prefer-promise-reject-errors': 'error', /** * parseInt 必须传入第二个参数 * @category Best Practices */ radix: 'error', /** * async 函数中必须存在 await 语句 * @category Best Practices * @reason async function 中没有 await 的写法很常见，koa 的示例中就有这种用法 */ 'require-await': 'off', /** * 正则表达式中必须要加上 u 标志 * @category Best Practices */ 'require-unicode-regexp': 'off', /** * var 必须在作用域的最前面 * @category Best Practices * @reason var 不在最前面也是很常见的用法 */ 'vars-on-top': 'off', /** * 必须使用 if (foo === 5) 而不是 if (5 === foo) * @category Best Practices */ yoda: [ 'error', 'never', &#123; onlyEquality: true &#125; ], /** * 禁止使用 'strict'; * @category Strict Mode */ strict: ['error', 'never'], /** * 变量必须在定义的时候赋值 * @category Variables * @reason 先定义后赋值很常见 */ 'init-declarations': 'off', /** * 禁止使用 delete * @category Variables */ 'no-delete-var': 'error', /** * 禁止 label 名称与定义过的变量重复 * @category Variables * @reason 已经禁止使用 label 了 */ 'no-label-var': 'off', /** * 禁止使用指定的全局变量 * @category Variables * @reason 它用于限制某个具体的变量名不能使用 */ 'no-restricted-globals': 'off', /** * 禁止变量名与上层作用域内的定义过的变量重复 * @category Variables * @reason 很多时候函数的形参和传参是同名的 */ 'no-shadow': 'off', /** * 禁止使用保留字作为变量名 * @category Variables */ 'no-shadow-restricted-names': 'error', /** * 禁止使用未定义的变量 * @category Variables */ 'no-undef': [ 'error', &#123; typeof: false &#125; ], /** * 禁止将 undefined 赋值给变量 * @category Variables */ 'no-undef-init': 'error', /** * 禁止使用 undefined * @category Variables */ 'no-undefined': 'off', /** * 定义过的变量必须使用 * @category Variables */ 'no-unused-vars': [ 'error', &#123; vars: 'all', args: 'none', caughtErrors: 'none', ignoreRestSiblings: true &#125; ], /** * 变量必须先定义后使用 * @category Variables */ 'no-use-before-define': [ 'error', &#123; functions: false, classes: false, variables: false &#125; ], /** * callback 之后必须立即 return * @category Node.js and CommonJS */ 'callback-return': 'off', /** * require 必须在全局作用域下 * @category Node.js and CommonJS * @reason 条件加载很常见 */ 'global-require': 'off', /** * callback 中的 error 必须被处理 * @category Node.js and CommonJS */ 'handle-callback-err': 'error', /** * 禁止直接使用 Buffer * @category Node.js and CommonJS */ 'no-buffer-constructor': 'error', /** * 相同类型的 require 必须放在一起 * @category Node.js and CommonJS */ 'no-mixed-requires': 'off', /** * 禁止直接 new require('foo') * @category Node.js and CommonJS */ 'no-new-require': 'error', /** * 禁止对 __dirname 或 __filename 使用字符串连接 * @category Node.js and CommonJS */ 'no-path-concat': 'error', /** * 禁止使用 process.env.NODE_ENV * @category Node.js and CommonJS * @reason 使用很常见 */ 'no-process-env': 'off', /** * 禁止使用 process.exit(0) * @category Node.js and CommonJS * @reason 使用很常见 */ 'no-process-exit': 'off', /** * 禁止使用指定的模块 * @category Node.js and CommonJS * @reason 它用于限制某个具体的模块不能使用 */ 'no-restricted-modules': 'off', /** * 禁止使用 node 中的同步的方法，比如 fs.readFileSync * @category Node.js and CommonJS * @reason 使用很常见 */ 'no-sync': 'off', /** * 变量名必须是 camelcase 风格的 * @category Stylistic Issues * @reason 很多 api 或文件名都不是 camelcase */ camelcase: 'off', /** * 注释的首字母必须大写 * @category Stylistic Issues */ 'capitalized-comments': 'off', /** * 限制 this 的别名 * @category Stylistic Issues */ 'consistent-this': 'off', /** * 函数赋值给变量的时候，函数名必须与变量名一致 * @category Stylistic Issues */ 'func-name-matching': [ 'error', 'always', &#123; includeCommonJSModuleExports: false &#125; ], /** * 函数必须有名字 * @category Stylistic Issues */ 'func-names': 'off', /** * 必须只使用函数声明或只使用函数表达式 * @category Stylistic Issues */ 'func-style': 'off', /** * 禁止使用指定的标识符 * @category Stylistic Issues * @reason 它用于限制某个具体的标识符不能使用 */ 'id-blacklist': 'off', /** * 限制变量名长度 * @category Stylistic Issues * @reason 没必要限制变量名长度 */ 'id-length': 'off', /** * 限制变量名必须匹配指定的正则表达式 * @category Stylistic Issues * @reason 没必要限制变量名 */ 'id-match': 'off', /** * 单行注释必须写在上一行 * @category Stylistic Issues */ 'line-comment-position': 'off', /** * 类的成员之间是否需要空行 * @category Stylistic Issues * @reason 有时为了紧凑需要挨在一起，有时为了可读性需要空一行 */ 'lines-between-class-members': 'off', /** * 代码块嵌套的深度禁止超过 5 层 * @category Stylistic Issues */ 'max-depth': ['error', 5], /** * 限制一个文件最多的行数 * @category Stylistic Issues */ 'max-lines': 'off', /** * 限制函数块中的代码行数 * @category Stylistic Issues */ 'max-lines-per-function': 'off', /** * 回调函数嵌套禁止超过 3 层，多了请用 async await 替代 * @category Stylistic Issues */ 'max-nested-callbacks': ['error', 3], /** * 函数的参数禁止超过 7 个 * @category Stylistic Issues */ 'max-params': ['error', 7], /** * 限制函数块中的语句数量 * @category Stylistic Issues */ 'max-statements': 'off', /** * 限制一行中的语句数量 * @category Stylistic Issues */ 'max-statements-per-line': 'off', /** * 约束多行注释的格式 * @category Stylistic Issues * @reason 能写注释已经不容易了，不需要限制太多 */ 'multiline-comment-style': 'off', /** * new 后面的类名必须首字母大写 * @category Stylistic Issues */ 'new-cap': [ 'error', &#123; newIsCap: true, capIsNew: false, properties: true &#125; ], /** * 禁止使用 Array 构造函数 * @category Stylistic Issues */ 'no-array-constructor': 'error', /** * 禁止使用位运算 * @category Stylistic Issues * @reason 位运算很常见 */ 'no-bitwise': 'off', /** * 禁止使用 continue * @category Stylistic Issues * @reason continue 很常用 */ 'no-continue': 'off', /** * 禁止在代码后添加内联注释 * @category Stylistic Issues * @reason 内联注释很常用 */ 'no-inline-comments': 'off', /** * 禁止 else 中只有一个单独的 if * @category Stylistic Issues * @reason 单独的 if 可以把逻辑表达的更清楚 */ 'no-lonely-if': 'off', /** * 禁止连续赋值，比如 a = b = c = 5 * @category Stylistic Issues */ 'no-multi-assign': 'off', /** * 禁止 if 里面有否定的表达式 * @category Stylistic Issues * @reason 否定的表达式可以把逻辑表达的更清楚 */ 'no-negated-condition': 'off', /** * 禁止使用嵌套的三元表达式，比如 a ? b : c ? d : e * @category Stylistic Issues */ 'no-nested-ternary': 'off', /** * 禁止直接 new Object * @category Stylistic Issues */ 'no-new-object': 'error', /** * 禁止使用 ++ 或 -- * @category Stylistic Issues */ 'no-plusplus': 'off', /** * 禁止使用特定的语法 * @category Stylistic Issues * @reason 它用于限制某个具体的语法不能使用 */ 'no-restricted-syntax': 'off', /** * 禁止使用三元表达式 * @category Stylistic Issues * @reason 三元表达式很常用 */ 'no-ternary': 'off', /** * 禁止变量名出现下划线 * @category Stylistic Issues * @reason 下划线在变量名中很常用 */ 'no-underscore-dangle': 'off', /** * 必须使用 !a 替代 a ? false : true * @category Stylistic Issues * @reason 后者表达的更清晰 */ 'no-unneeded-ternary': 'off', /** * 禁止变量申明时用逗号一次申明多个 * @category Stylistic Issues */ 'one-var': ['error', 'never'], /** * 必须使用 x = x + y 而不是 x += y * @category Stylistic Issues */ 'operator-assignment': 'off', /** * 限制语句之间的空行规则，比如变量定义完之后必须要空行 * @category Stylistic Issues */ 'padding-line-between-statements': 'off', /** * 使用 ... 而不是 Object.assign * @category Stylistic Issues */ 'prefer-object-spread': 'error', /** * 对象字面量的键名必须排好序 * @category Stylistic Issues */ 'sort-keys': 'off', /** * 变量申明必须排好序 * @category Stylistic Issues */ 'sort-vars': 'off', /** * 注释的斜线或 * 后必须有空格 * @category Stylistic Issues */ 'spaced-comment': [ 'error', 'always', &#123; block: &#123; exceptions: ['*'], balanced: true &#125; &#125; ], /** * constructor 中必须有 super * @category ECMAScript 6 */ 'constructor-super': 'error', /** * 禁止对定义过的 class 重新赋值 * @category ECMAScript 6 */ 'no-class-assign': 'error', /** * 禁止对使用 const 定义的常量重新赋值 * @category ECMAScript 6 */ 'no-const-assign': 'error', /** * 禁止重复定义类 * @category ECMAScript 6 */ 'no-dupe-class-members': 'error', /** * 禁止重复导入模块 * @category ECMAScript 6 */ 'no-duplicate-imports': 'error', /** * 禁止使用 new 来生成 Symbol * @category ECMAScript 6 */ 'no-new-symbol': 'error', /** * 禁止导入指定的模块 * @category ECMAScript 6 * @reason 它用于限制某个具体的模块不能使用 */ 'no-restricted-imports': 'off', /** * 禁止在 super 被调用之前使用 this 或 super * @category ECMAScript 6 */ 'no-this-before-super': 'error', /** * 禁止出现没必要的计算键名，比如 let a = &#123; ['0']: 0 &#125;; * @category ECMAScript 6 */ 'no-useless-computed-key': 'error', /** * 禁止出现没必要的 constructor，比如 constructor(value) &#123; super(value) &#125; * @category ECMAScript 6 */ 'no-useless-constructor': 'error', /** * 禁止解构赋值时出现同样名字的的重命名，比如 let &#123; foo: foo &#125; = bar; * @category ECMAScript 6 */ 'no-useless-rename': 'error', /** * 禁止使用 var * @category ECMAScript 6 */ 'no-var': 'error', /** * 必须使用 a = &#123;b&#125; 而不是 a = &#123;b: b&#125; * @category ECMAScript 6 * @reason 没必要强制要求 */ 'object-shorthand': 'off', /** * 申明后不再被修改的变量必须使用 const 来申明 * @category ECMAScript 6 * @reason 没必要强制要求 */ 'prefer-const': 'off', /** * 必须使用解构赋值 * @category ECMAScript 6 */ 'prefer-destructuring': 'off', /** * 必须使用 0b11111011 而不是 parseInt('111110111', 2) * @category ECMAScript 6 * @reason 没必要强制要求 */ 'prefer-numeric-literals': 'off', /** * 必须使用 ...args 而不是 arguments * @category ECMAScript 6 * @reason 没必要强制要求 */ 'prefer-rest-params': 'off', /** * 必须使用 ... 而不是 apply，比如 foo(...args) * @category ECMAScript 6 * @reason apply 很常用 */ 'prefer-spread': 'off', /** * 必须使用模版字符串而不是字符串连接 * @category ECMAScript 6 * @reason 字符串连接很常用 */ 'prefer-template': 'off', /** * generator 函数内必须有 yield * @category ECMAScript 6 */ 'require-yield': 'error', /** * 导入必须按规则排序 * @category ECMAScript 6 * @reason 没必要强制要求 */ 'sort-imports': 'off', /** * 创建 Symbol 时必须传入参数 * @category ECMAScript 6 */ 'symbol-description': 'error' &#125;&#125;; VUE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304module.exports = &#123; parser: 'vue-eslint-parser', parserOptions: &#123; // 设置 js 的解析器为 babel-eslint // https://github.com/mysticatea/vue-eslint-parser#-options parser: 'babel-eslint', ecmaVersion: 2019, // ECMAScript modules 模式 sourceType: 'module', ecmaFeatures: &#123; // 不允许 return 语句出现在 global 环境下 globalReturn: false, // 开启全局 script 模式 impliedStrict: true, jsx: true &#125;, // 即使没有 babelrc 配置文件，也使用 babel-eslint 来解析 requireConfigFile: false, // 仅允许 import export 语句出现在模块的顶层 allowImportExportEverywhere: false &#125;, plugins: ['vue'], rules: &#123; /** * 支持在模版中使用 eslint-disable-next-line 等注释 * @category Enabling Correct ESLint Parsing */ 'vue/comment-directive': 'error', /** * 定义了的 jsx element 必须使用 * @category Enabling Correct ESLint Parsing */ 'vue/jsx-uses-vars': 'error', /** * 计算属性禁止包含异步方法 * @category Error Prevention */ 'vue/no-async-in-computed-properties': 'error', /** * 禁止重复的二级键名 * @category Error Prevention */ 'vue/no-dupe-keys': 'off', /** * 禁止出现重复的属性 * @category Error Prevention */ 'vue/no-duplicate-attributes': 'error', /** * 禁止出现语法错误 * @category Error Prevention */ 'vue/no-parsing-error': 'error', /** * 禁止覆盖保留字 * @category Error Prevention */ 'vue/no-reserved-keys': 'error', /** * 组件的 data 属性的值必须是一个函数 * @category Error Prevention */ 'vue/no-shared-component-data': 'off', /** * 禁止在计算属性中对属性修改 * @category Error Prevention */ 'vue/no-side-effects-in-computed-properties': 'off', /** * 禁止 &lt;template&gt; 使用 key 属性 * @category Error Prevention */ 'vue/no-template-key': 'off', /** * 禁止在 &lt;textarea&gt; 中出现 &#123;&#123;message&#125;&#125; * @category Error Prevention */ 'vue/no-textarea-mustache': 'error', /** * 禁止定义在 components 中的组件未使用 * @category Error Prevention */ 'vue/no-unused-components': 'error', /** * 禁止模版中定义的变量未使用 * @category Error Prevention */ 'vue/no-unused-vars': 'error', /** * 禁止在同一个元素上使用 v-if 和 v-for 指令 * @category Error Prevention */ 'vue/no-use-v-if-with-v-for': 'error', /** * &lt;component&gt; 必须有 v-bind:is * @category Error Prevention */ 'vue/require-component-is': 'error', /** * props 的取值必须是构造函数 * @category Error Prevention */ 'vue/require-prop-type-constructor': 'error', /** * render 函数必须有返回值 * @category Error Prevention */ 'vue/require-render-return': 'error', /** * v-for 指令的元素必须有 v-bind:key * @category Error Prevention */ 'vue/require-v-for-key': 'error', /** * prop 的默认值必须匹配它的类型 * @category Error Prevention */ 'vue/require-valid-default-prop': 'off', /** * 计算属性必须有返回值 * @category Error Prevention */ 'vue/return-in-computed-property': 'error', /** * 当一个节点上出现两个 v-on:click 时，其中一个必须为 exact * @category Error Prevention */ 'vue/use-v-on-exact': 'error', /** * template 的根节点必须合法 * @category Error Prevention */ 'vue/valid-template-root': 'error', /** * v-bind 指令必须合法 * @category Error Prevention */ 'vue/valid-v-bind': 'error', /** * v-cloak 指令必须合法 * @category Error Prevention */ 'vue/valid-v-cloak': 'error', /** * v-else 指令必须合法 * @category Error Prevention */ 'vue/valid-v-else': 'error', /** * v-else-if 指令必须合法 * @category Error Prevention */ 'vue/valid-v-else-if': 'error', /** * v-for 指令必须合法 * @category Error Prevention */ 'vue/valid-v-for': 'error', /** * v-html 指令必须合法 * @category Error Prevention */ 'vue/valid-v-html': 'error', /** * v-if 指令必须合法 * @category Error Prevention */ 'vue/valid-v-if': 'error', /** * v-model 指令必须合法 * @category Error Prevention */ 'vue/valid-v-model': 'error', /** * v-on 指令必须合法 * @category Error Prevention */ 'vue/valid-v-on': 'error', /** * v-once 指令必须合法 * @category Error Prevention */ 'vue/valid-v-once': 'error', /** * v-pre 指令必须合法 * @category Error Prevention */ 'vue/valid-v-pre': 'error', /** * v-show 指令必须合法 * @category Error Prevention */ 'vue/valid-v-show': 'error', /** * v-text 指令必须合法 * @category Error Prevention */ 'vue/valid-v-text': 'error', /** * 限制自定义组件的属性风格 * @category Improving Readability */ 'vue/attribute-hyphenation': 'off', /** * 限制组件的 name 属性的值的风格 * @category Improving Readability */ 'vue/name-property-casing': 'off', /** * 模版中的变量名禁止与前一个作用域重名 * @category Improving Readability */ 'vue/no-template-shadow': 'off', /** * props 必须用驼峰式 * @category Improving Readability */ 'vue/prop-name-casing': 'off', /** * props 如果不是 required 的字段，必须有默认值 * @category Improving Readability */ 'vue/require-default-prop': 'error', /** * prop 必须有类型限制 * @category Improving Readability */ 'vue/require-prop-types': 'off', /** * 限制 v-bind 的风格 * @category Improving Readability */ 'vue/v-bind-style': 'off', /** * 限制 v-on 的风格 * @category Improving Readability */ 'vue/v-on-style': 'off', /** * 标签属性必须按规则排序 * @category Minimizing Arbitrary Choices and Cognitive Overhead */ 'vue/attributes-order': 'error', /** * 禁用 v-html * @category Minimizing Arbitrary Choices and Cognitive Overhead */ 'vue/no-v-html': 'off', /** * 组件的属性必须为一定的顺序 * @category Minimizing Arbitrary Choices and Cognitive Overhead */ 'vue/order-in-components': 'error', /** * 禁止在模版中用 this * @category Minimizing Arbitrary Choices and Cognitive Overhead */ 'vue/this-in-template': 'error', /** * 变量名必须是 camelcase 风格的 * @category Uncategorized * @reason 很多 api 或文件名都不是 camelcase */ 'vue/camelcase': 'off', /** * 对象的最后一个属性末尾必须有逗号 * @category Uncategorized */ 'vue/comma-dangle': 'off', /** * 必须使用 === 或 !==，禁止使用 == 或 != * @category Uncategorized */ 'vue/eqeqeq': ['error', 'always'], /** * 组件名称必须和文件名一致 * @category Uncategorized */ 'vue/match-component-file-name': 'off', /** * 禁止给布尔值 props 添加默认值 * @category Uncategorized */ 'vue/no-boolean-default': 'off', /** * 禁止使用特定的语法 * @category Uncategorized * @reason 它用于限制某个具体的语法不能使用 */ 'vue/no-restricted-syntax': 'off', /** * 禁止手动 export default * @category Uncateg![f4f1ea73165f6d9a15adb99b02ed7cc4.png](en-resource://database/1004:1) orized */ 'vue/require-direct-export': 'error', /** * 禁止在 v-on 的值中调用函数 * @category Uncategorized */ 'vue/v-on-function-call': 'error' &#125;&#125;;]]></content>
      <tags>
        <tag>Eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置]]></title>
    <url>%2Farticles%2F2841722370.html</url>
    <content type="text"><![CDATA[VSCode 作为如今最受欢迎的编辑器，为了它的高效性，需要搭配很多插件来使用 配置说明详解editor是针对 vscode 的风格设置例如 tabSize：一个 tab 等于 2 个空格，行高为 24px search.exclude 配置 vscode 中项目中的哪些地方被排除搜索,避免你每次搜索结果中都有一大堆无关内容 files.associations 配置文件关联 sync是用于同步 vscode 配置使用，不用每一次换个电脑都要复制一次配置，避免丢失或者改动，保持一致！ vetur和prettier和stylus是用于 Vue 开发时的代码格式化，代码提示. eslint 是用于代码格式化代码时，选择用自己的格式化规则或者标准规则，prettier规则等 插件安装Atom One Dark Theme主题 Chinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包 Prettier - Code formatter用于 Visual Studio 代码的更漂亮的格式化程序 ESLint语法规则和代码风格的检查工具 indent-rainbow凸显缩进，让你的缩进一目了然 Git Historygit 提交历史 GitLens在代码中显示每一行代码的提交历史 Vetur添加对.vue 后缀文件的快速书写支持。 View In Browser迅速通过浏览器打开 html 文件 markdownlint书写 md 文件的预览插件 koroFileHeader在vscode中用于生成文件头部注释和函数注释的插件 Path Intellisense路径识别苦战，比如书写图片路径时。遗憾就是，对 webpack 项目中的路径别名无法扩展 Document This快速生成注释，注意只对类和函数有效。快捷键 Ctrl+Alt+D vscode 自定义配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; "workbench.colorTheme": "Atom One Dark",//主题 "editor.renderIndentGuides": false, "search.location": "panel",//搜索模块放到下方菜单 "eslint.autoFixOnSave": true,//保存代码自动eslint格式化 "eslint.enable": true,//是否开启eslint "editor.formatOnSave": true,//保存自动格式化 "eslint.validate": [//eslint 校验配置 "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125;, &#123; "language": "vue", "autoFix": true &#125; ], "files.associations": &#123; "*.cjson": "jsonc", "*.wxss": "css", "*.wxs": "javascript" &#125;, "vetur.format.defaultFormatter.html": "prettier",//prettier格式化代码 "emmet.includeLanguages": &#123; "wxml": "html" &#125;, "minapp-vscode.disableAutoConfig": true, "vsicons.dontShowNewVersionMessage": true, "editor.fontSize": 16,//文字大小 "terminal.integrated.shell.windows": "C:\\Program Files\\Git\\bin\\bash.exe", "[javascript]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;, "eslint.alwaysShowStatus": true, "fileheader.customMade":&#123;//自动化注释配置 "Author": "yuwangi", "Date": "Do not edit", "LastEditTime": "Do not edit", "LastEditors": "Do not edit", "FilePath": "Do not edit", "Description": "" &#125;, "fileheader.configObj": &#123; "specialOptions":&#123; "Date": "since", "LastEditTime": "lastTime", "LastEditors": "LastAuthor", "Description": "message" &#125; &#125;&#125;]]></content>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock自定义配置]]></title>
    <url>%2Farticles%2F1932561252.html</url>
    <content type="text"><![CDATA[为什么需要Mock 这样的场景，相信大家会觉得似曾相识。 为此，我们就需要使用一些工具来帮助我们将业务单元之间尽量解耦，它就是Mock 实现Mock古代没有出现Mock前，为了能模拟数据，一般屏蔽请求代码，然后写死数据，比如： 1234567891011// this.$http.get("/maps/aoi_user_search/").then(// function(res) &#123;// setData(res);// &#125;,// function(res) &#123;// console.log(res.status);// &#125;// );let res=&#123;a:1,b:2&#125;setData(res); 这种方式很简单，起码当初就照这个方式继续开发了，虽然后续接口有数据，改起来很麻烦。但是也会常常遇到忘记把模拟数据移除，导致实际使用的时候一直是假数据，而非真实数据，为此出现过多次。所以为了解决这个问题，就用到了Mock。 近代在这个时候，我们就拥有了MockJS,通过使用MockJS我们能根据模板和规则生成复杂的接口数据，而无需我们自己动手去书写，例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//apisimport api from '../api/index';import Mock from 'mockjs';var obj = &#123;'aa':'11', 'bb':'22', 'cc':'33', 'dd':'44'&#125;;function getApiMessage() &#123; return new Promise((resolve) =&gt; &#123; resolve(Mock.mock('http://test.com', &#123; "user|1-3": [&#123; // 随机生成1到3个数组元素 'name': '@cname', // 中文名称 'id|+1': 88, // 属性值自动加 1，初始值为88 'age|18-28': 0, // 18至28以内随机整数, 0只是用来确定类型 'birthday': '@date("yyyy-MM-dd")', // 日期 'city': '@city(true)', // 中国城市 'color': '@color', // 16进制颜色 'isMale|1': true, // 布尔值 'isFat|1-2': true, // true的概率是1/3 'fromObj|2': obj, // 从obj对象中随机获取2个属性 'fromObj2|1-3': obj, // 从obj对象中随机获取1至3个属性 'brother|1': ['jack', 'jim'], // 随机选取 1 个元素 'sister|+1': ['jack', 'jim', 'lily'], // array中顺序选取元素作为结果 'friends|2': ['jack', 'jim'] // 重复2次属性值生成一个新数组 &#125;,&#123; 'gf': '@cname' &#125;] &#125;)); &#125;) // return api.getApiMessage();&#125;/***通过模板 生成的数据格式*&#123;* "user": [* &#123;* "name": "董静",* "id": 88,* "age": 25,* "birthday": "2015-04-01",* "city": "湖南省 怀化市",* "color": "#c0f279",* "isMale": false,* "isFat": false,* "fromObj": &#123;* "dd": "44",* "aa": "11"* &#125;,* "fromObj2": &#123;* "bb": "22",* "cc": "33"* &#125;,* "brother": "jack",* "sister": "jack",* "friends": [* "jack",* "jim",* "jack",* "jim"* ]* &#125;,* &#123;* "gf": "田杰"* &#125;* ]*&#125;**/ 这种方式也只是方便我们造假数据，而并不能方便的抽离出我们的代码,而且数据也不足够真实。有关mockjs相关语法参考http://mockjs.com/examples.html#String这个时候想一下，我们Mock数据的需求： 模拟数据 模拟数据与代码完全分离 通过一些配置，可以只获取部分Mock数据，最好足够真实 首先，如果我们想要把代码跟数据完全分离，我们必须想办法在请求的时候做一些操作，让本应请求正式数据的接口去请求Mock数据，做一个请求拦截，请求拦截的方式有两种： 一种是修改请求的链接，来达到Mock数据 12345678910111213141516//main.vueservice.getBuildingListByPage(&#123; ...params, mock:true&#125;)//server.jsgetBuildingListByPage: params =&gt; &#123; let baseApi=env.baseApi if(params.mock)&#123; baseApi='127.0.0.1:8080' &#125; return fly.get( env.baseApi + "g/bam/c/quote/building-list", params ) &#125; 此方法需自己搭一个node服务，然后写一些接口返回数据。 另外一种就是检测出Mock，直接从mock文件中取出数据 12345678910111213141516171819202122232425262728293031323334//main.vueservice.getBuildingListByPage(&#123; ...params, mock:true&#125;)//mock/db.jsexport default &#123; getBuildingListByPage: &#123; err_code: 0, err_msg: "ok", data: [ &#123; time: "2019-05-29 00:00:00", aging: 0 &#125;, &#123; time: "2019-05-29 01:00:00", aging: 16 &#125; ] &#125;&#125;//server.jsimport mockData from 'mock/db.js';getBuildingListByPage: params =&gt; &#123; let baseApi=env.baseApi if(params.mock)&#123; return mockData[getBuildingListByPage] &#125; return fly.get( env.baseApi + "g/building-list", params ) &#125; 乍一看好像第二种方式似乎更简单，事实也确实如此。但是这样用起来还不是很方便，而且接口多了，Mock数据文件会很大，需要做一个拆分。所以就有了后来的配置。 现代tips:现在的配置基于webpack的devServer在webpack中做转发代理，所有请求会先过before这个回调函数： 123456789101112131415161718192021222324252627282930313233const path = require('path');const webpack = require('webpack');const merge = require('webpack-merge');const BaseConfig = require('./webpack.base.js');const apiMocker = require('mocker-api');//webpack配置mode: 'development', devServer: &#123; host: '0.0.0.0', port: 9001, headers: &#123; 'Access-Control-Allow-Origin': '*' &#125;, historyApiFallback: &#123; rewrites: [&#123; from: /.*/g, to: '/www/view/index.html' &#125;] &#125;, proxy: &#123; '/api': &#123; target: 'http://10.12.67.192:8091/' &#125; &#125;, before(app) &#123; //https://www.webpackjs.com/configuration/dev-server/#devserver-before apiMocker(app, path.resolve(__dirname, '../mock/index.js')); &#125; &#125;, Mock资源文件JSON文件 123456789101112131415161718192021&#123; "err_code": 0, "err_msg": "ok", "mock": true, "data": &#123; "poi": &#123; "z_id": "111111111111", "name": "中国技术交易大厦大厦大厦", "province": "", "city": "北京市", "district": "海淀区", "longitude": 116.307499005, "latitude": 39.111, "addr": "", "category": "房产小区:商务楼宇", "category_code": 281200, "expiration_label": 0, "phone": "" &#125; &#125;&#125; Mockjs配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const delay = require('mocker-api/utils/delay');const fs = require('fs');const dirCur = fs.readdirSync(__dirname);const path = require('path');const MOCK = process.env.MOCK || process.env.mock || process.env.Mock;const apiList = &#123;&#125;;dirCur.forEach(item =&gt; &#123; const basename = path.basename(item, '.json'); if (basename !== 'index.js') &#123; const apiName = 'POST /api/' + basename.replace(/[A-Z]/g, math =&gt; &#123; return '/' + math.toLowerCase(); &#125;); let apiData = fs.readFileSync(path.join(__dirname, item), 'utf8'); try &#123; apiData = JSON.parse(apiData); &#125; catch (e) &#123; console.log(item, e); &#125; if (MOCK || apiData.mock) &#123; apiList[apiName] = (req, res, next) =&gt; &#123; console.log('Mock API:' + req.path); res.json(apiData); &#125;; &#125; &#125;&#125;);// 'GET /api/edit/apply': (req, res) =&gt; &#123;// const &#123; owner, repo, ref &#125; = req.params;// return res.json(&#123;// id: 1,// owner, repo, ref,// path: req.params[0]// &#125;);// &#125;,// const proxy = loadData(&#123;// 'POST /api/edit/apply': './editApply',// 'POST /api/verify/apply': './verifyApply',// 'POST /api/accept/apply': './editApply',// 'POST /api/edit/submit': './editSubmit',// 'POST /api/verify/submit': './editSubmit',// 'POST /api/accept/submit': './editSubmit',// 'POST /api/rawore/get': './raworeGet',// 'POST /api/poi/history': './poiHistory',// 'POST /api/edit/history': './editHistory',// 'POST /api/verify/history': './editHistory',// 'POST /api/accept/history': './editHistory',// 'POST /api/user/get': './userGet',// 'POST /api/work/history': './historyList',// 'POST /api/statistic/gainproduct': './gainproduction',// 'POST /api/statistic/accuracy': './accuracy',// 'POST /api/statistic/aging': './aging',// 'POST /api/company/list': './companyList',// 'POST /api/user/list': './listuser'// &#125;);module.exports = delay(apiList, 10); json文件采取驼峰命名方式，然后通过正则判断大写,替换成/+小写路径，然后用node中的fs读取当前文件夹下所有文件，得到文件列表遍历，读取文件内容，最后判断是否开发模式或是否开启Mock,然后返回数据。 关于MOCK全部开启,package.json配置： mocker-api-json 最近刚刚发布的npm包mocker-api-json 参考资料https://www.jianshu.com/p/adb6ff1df3d6https://www.npmjs.com/package/mocker-api]]></content>
      <tags>
        <tag>Mock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Farticles%2F1243066710.html</url>
    <content type="text"><![CDATA[第一篇文章自然要用 Hello World 开头，写博客就是想把平常用到的东西积累下来。 Hello World1console.log("Hello World");]]></content>
  </entry>
</search>
